/*
SCP LoadBalancer Service

SCP LoadBalancer Service

API version: 0.0.1.dev1712
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package loadbalancer

import (
	"bytes"
	"context"
	scpsdk "github.com/SamsungSDSCloud/terraform-sdk-samsungcloudplatformv2/client"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// LoadbalancerV1LoadbalancersApiAPIService LoadbalancerV1LoadbalancersApiAPI service
type LoadbalancerV1LoadbalancersApiAPIService service

type LoadbalancerV1LoadbalancersApiAPICheckLoadbalancerCreationRequest struct {
	ctx        context.Context
	ApiService *LoadbalancerV1LoadbalancersApiAPIService
	subnetId   string
}

func (r LoadbalancerV1LoadbalancersApiAPICheckLoadbalancerCreationRequest) Execute() (*LoadbalancerCreateValidateResponse, *http.Response, error) {
	return r.ApiService.CheckLoadbalancerCreationExecute(r)
}

/*
CheckLoadbalancerCreation CheckLoadbalancerCreation

check Load Balancer creation availability

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param subnetId Subnet ID
	@return LoadbalancerV1LoadbalancersApiAPICheckLoadbalancerCreationRequest
*/
func (a *LoadbalancerV1LoadbalancersApiAPIService) CheckLoadbalancerCreation(ctx context.Context, subnetId string) LoadbalancerV1LoadbalancersApiAPICheckLoadbalancerCreationRequest {
	return LoadbalancerV1LoadbalancersApiAPICheckLoadbalancerCreationRequest{
		ApiService: a,
		ctx:        ctx,
		subnetId:   subnetId,
	}
}

// Execute executes the request
//
//	@return LoadbalancerCreateValidateResponse
func (a *LoadbalancerV1LoadbalancersApiAPIService) CheckLoadbalancerCreationExecute(r LoadbalancerV1LoadbalancersApiAPICheckLoadbalancerCreationRequest) (*LoadbalancerCreateValidateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LoadbalancerCreateValidateResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/loadbalancers/{subnet_id}/check-lb-create-available"
	localVarPath = strings.Replace(localVarPath, "{"+"subnet_id"+"}", url.PathEscape(parameterValueToString(r.subnetId, "subnetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "loadbalancer 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LoadbalancerV1LoadbalancersApiAPICreateLoadbalancerRequest struct {
	ctx                       context.Context
	ApiService                *LoadbalancerV1LoadbalancersApiAPIService
	loadbalancerCreateRequest *LoadbalancerCreateRequest
}

func (r LoadbalancerV1LoadbalancersApiAPICreateLoadbalancerRequest) LoadbalancerCreateRequest(loadbalancerCreateRequest LoadbalancerCreateRequest) LoadbalancerV1LoadbalancersApiAPICreateLoadbalancerRequest {
	r.loadbalancerCreateRequest = &loadbalancerCreateRequest
	return r
}

func (r LoadbalancerV1LoadbalancersApiAPICreateLoadbalancerRequest) Execute() (*LoadbalancerShowResponse, *http.Response, error) {
	return r.ApiService.CreateLoadbalancerExecute(r)
}

/*
CreateLoadbalancer CreateLoadbalancer

create Load Balancer

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return LoadbalancerV1LoadbalancersApiAPICreateLoadbalancerRequest
*/
func (a *LoadbalancerV1LoadbalancersApiAPIService) CreateLoadbalancer(ctx context.Context) LoadbalancerV1LoadbalancersApiAPICreateLoadbalancerRequest {
	return LoadbalancerV1LoadbalancersApiAPICreateLoadbalancerRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return LoadbalancerShowResponse
func (a *LoadbalancerV1LoadbalancersApiAPIService) CreateLoadbalancerExecute(r LoadbalancerV1LoadbalancersApiAPICreateLoadbalancerRequest) (*LoadbalancerShowResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LoadbalancerShowResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/loadbalancers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.loadbalancerCreateRequest == nil {
		return localVarReturnValue, nil, reportError("loadbalancerCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "loadbalancer 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.loadbalancerCreateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LoadbalancerV1LoadbalancersApiAPICreateLoadbalancerPublicNatIpRequest struct {
	ctx                    context.Context
	ApiService             *LoadbalancerV1LoadbalancersApiAPIService
	loadbalancerId         string
	staticNatCreateRequest *StaticNatCreateRequest
}

func (r LoadbalancerV1LoadbalancersApiAPICreateLoadbalancerPublicNatIpRequest) StaticNatCreateRequest(staticNatCreateRequest StaticNatCreateRequest) LoadbalancerV1LoadbalancersApiAPICreateLoadbalancerPublicNatIpRequest {
	r.staticNatCreateRequest = &staticNatCreateRequest
	return r
}

func (r LoadbalancerV1LoadbalancersApiAPICreateLoadbalancerPublicNatIpRequest) Execute() (*StaticNatCreateResponse, *http.Response, error) {
	return r.ApiService.CreateLoadbalancerPublicNatIpExecute(r)
}

/*
CreateLoadbalancerPublicNatIp CreateLoadbalancerPublicNatIp

create Load Balancer Public NAT IP

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param loadbalancerId ID
	@return LoadbalancerV1LoadbalancersApiAPICreateLoadbalancerPublicNatIpRequest
*/
func (a *LoadbalancerV1LoadbalancersApiAPIService) CreateLoadbalancerPublicNatIp(ctx context.Context, loadbalancerId string) LoadbalancerV1LoadbalancersApiAPICreateLoadbalancerPublicNatIpRequest {
	return LoadbalancerV1LoadbalancersApiAPICreateLoadbalancerPublicNatIpRequest{
		ApiService:     a,
		ctx:            ctx,
		loadbalancerId: loadbalancerId,
	}
}

// Execute executes the request
//
//	@return StaticNatCreateResponse
func (a *LoadbalancerV1LoadbalancersApiAPIService) CreateLoadbalancerPublicNatIpExecute(r LoadbalancerV1LoadbalancersApiAPICreateLoadbalancerPublicNatIpRequest) (*StaticNatCreateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StaticNatCreateResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/loadbalancers/{loadbalancer_id}/static-nats"
	localVarPath = strings.Replace(localVarPath, "{"+"loadbalancer_id"+"}", url.PathEscape(parameterValueToString(r.loadbalancerId, "loadbalancerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.staticNatCreateRequest == nil {
		return localVarReturnValue, nil, reportError("staticNatCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "loadbalancer 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.staticNatCreateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LoadbalancerV1LoadbalancersApiAPIDeleteLoadbalancerRequest struct {
	ctx            context.Context
	ApiService     *LoadbalancerV1LoadbalancersApiAPIService
	loadbalancerId string
}

func (r LoadbalancerV1LoadbalancersApiAPIDeleteLoadbalancerRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLoadbalancerExecute(r)
}

/*
DeleteLoadbalancer DeleteLoadbalancer

delete Load Balancer

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param loadbalancerId ID
	@return LoadbalancerV1LoadbalancersApiAPIDeleteLoadbalancerRequest
*/
func (a *LoadbalancerV1LoadbalancersApiAPIService) DeleteLoadbalancer(ctx context.Context, loadbalancerId string) LoadbalancerV1LoadbalancersApiAPIDeleteLoadbalancerRequest {
	return LoadbalancerV1LoadbalancersApiAPIDeleteLoadbalancerRequest{
		ApiService:     a,
		ctx:            ctx,
		loadbalancerId: loadbalancerId,
	}
}

// Execute executes the request
func (a *LoadbalancerV1LoadbalancersApiAPIService) DeleteLoadbalancerExecute(r LoadbalancerV1LoadbalancersApiAPIDeleteLoadbalancerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return nil, err
		}
	}

	localVarPath := basePath + "/v1/loadbalancers/{loadbalancer_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"loadbalancer_id"+"}", url.PathEscape(parameterValueToString(r.loadbalancerId, "loadbalancerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	localVarHeaderParams["Scp-API-Version"] = "loadbalancer 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LoadbalancerV1LoadbalancersApiAPIDeleteLoadbalancerPublicNatIpRequest struct {
	ctx            context.Context
	ApiService     *LoadbalancerV1LoadbalancersApiAPIService
	loadbalancerId string
}

func (r LoadbalancerV1LoadbalancersApiAPIDeleteLoadbalancerPublicNatIpRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLoadbalancerPublicNatIpExecute(r)
}

/*
DeleteLoadbalancerPublicNatIp DeleteLoadbalancerPublicNatIp

delete Load Balancer Public NAT IP

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param loadbalancerId ID
	@return LoadbalancerV1LoadbalancersApiAPIDeleteLoadbalancerPublicNatIpRequest
*/
func (a *LoadbalancerV1LoadbalancersApiAPIService) DeleteLoadbalancerPublicNatIp(ctx context.Context, loadbalancerId string) LoadbalancerV1LoadbalancersApiAPIDeleteLoadbalancerPublicNatIpRequest {
	return LoadbalancerV1LoadbalancersApiAPIDeleteLoadbalancerPublicNatIpRequest{
		ApiService:     a,
		ctx:            ctx,
		loadbalancerId: loadbalancerId,
	}
}

// Execute executes the request
func (a *LoadbalancerV1LoadbalancersApiAPIService) DeleteLoadbalancerPublicNatIpExecute(r LoadbalancerV1LoadbalancersApiAPIDeleteLoadbalancerPublicNatIpRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return nil, err
		}
	}

	localVarPath := basePath + "/v1/loadbalancers/{loadbalancer_id}/static-nats"
	localVarPath = strings.Replace(localVarPath, "{"+"loadbalancer_id"+"}", url.PathEscape(parameterValueToString(r.loadbalancerId, "loadbalancerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	localVarHeaderParams["Scp-API-Version"] = "loadbalancer 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LoadbalancerV1LoadbalancersApiAPIListLoadbalancersRequest struct {
	ctx        context.Context
	ApiService *LoadbalancerV1LoadbalancersApiAPIService
	size       *int32
	page       *int32
	sort       *string
	name       *string
	state      *State
	serviceIp  *string
	subnetId   *string
}

// size
func (r LoadbalancerV1LoadbalancersApiAPIListLoadbalancersRequest) Size(size int32) LoadbalancerV1LoadbalancersApiAPIListLoadbalancersRequest {
	r.size = &size
	return r
}

// page
func (r LoadbalancerV1LoadbalancersApiAPIListLoadbalancersRequest) Page(page int32) LoadbalancerV1LoadbalancersApiAPIListLoadbalancersRequest {
	r.page = &page
	return r
}

// sort
func (r LoadbalancerV1LoadbalancersApiAPIListLoadbalancersRequest) Sort(sort string) LoadbalancerV1LoadbalancersApiAPIListLoadbalancersRequest {
	r.sort = &sort
	return r
}

// The name of the load balancer.
func (r LoadbalancerV1LoadbalancersApiAPIListLoadbalancersRequest) Name(name string) LoadbalancerV1LoadbalancersApiAPIListLoadbalancersRequest {
	r.name = &name
	return r
}

// The state of the load balancer.
func (r LoadbalancerV1LoadbalancersApiAPIListLoadbalancersRequest) State(state State) LoadbalancerV1LoadbalancersApiAPIListLoadbalancersRequest {
	r.state = &state
	return r
}

// The service IP of the load balancer.
func (r LoadbalancerV1LoadbalancersApiAPIListLoadbalancersRequest) ServiceIp(serviceIp string) LoadbalancerV1LoadbalancersApiAPIListLoadbalancersRequest {
	r.serviceIp = &serviceIp
	return r
}

// Subnet ID
func (r LoadbalancerV1LoadbalancersApiAPIListLoadbalancersRequest) SubnetId(subnetId string) LoadbalancerV1LoadbalancersApiAPIListLoadbalancersRequest {
	r.subnetId = &subnetId
	return r
}

func (r LoadbalancerV1LoadbalancersApiAPIListLoadbalancersRequest) Execute() (*LoadbalancerListResponse, *http.Response, error) {
	return r.ApiService.ListLoadbalancersExecute(r)
}

/*
ListLoadbalancers ListLoadbalancers

get Load Balancer list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return LoadbalancerV1LoadbalancersApiAPIListLoadbalancersRequest
*/
func (a *LoadbalancerV1LoadbalancersApiAPIService) ListLoadbalancers(ctx context.Context) LoadbalancerV1LoadbalancersApiAPIListLoadbalancersRequest {
	return LoadbalancerV1LoadbalancersApiAPIListLoadbalancersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return LoadbalancerListResponse
func (a *LoadbalancerV1LoadbalancersApiAPIService) ListLoadbalancersExecute(r LoadbalancerV1LoadbalancersApiAPIListLoadbalancersRequest) (*LoadbalancerListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LoadbalancerListResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/loadbalancers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	}
	if r.serviceIp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "service_ip", r.serviceIp, "form", "")
	}
	if r.subnetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subnet_id", r.subnetId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "loadbalancer 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LoadbalancerV1LoadbalancersApiAPISetLoadbalancerRequest struct {
	ctx                       context.Context
	ApiService                *LoadbalancerV1LoadbalancersApiAPIService
	loadbalancerId            string
	loadbalancerUpdateRequest *LoadbalancerUpdateRequest
}

func (r LoadbalancerV1LoadbalancersApiAPISetLoadbalancerRequest) LoadbalancerUpdateRequest(loadbalancerUpdateRequest LoadbalancerUpdateRequest) LoadbalancerV1LoadbalancersApiAPISetLoadbalancerRequest {
	r.loadbalancerUpdateRequest = &loadbalancerUpdateRequest
	return r
}

func (r LoadbalancerV1LoadbalancersApiAPISetLoadbalancerRequest) Execute() (*LoadbalancerShowResponse, *http.Response, error) {
	return r.ApiService.SetLoadbalancerExecute(r)
}

/*
SetLoadbalancer SetLoadbalancer

Set Load Balancer

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param loadbalancerId ID
	@return LoadbalancerV1LoadbalancersApiAPISetLoadbalancerRequest
*/
func (a *LoadbalancerV1LoadbalancersApiAPIService) SetLoadbalancer(ctx context.Context, loadbalancerId string) LoadbalancerV1LoadbalancersApiAPISetLoadbalancerRequest {
	return LoadbalancerV1LoadbalancersApiAPISetLoadbalancerRequest{
		ApiService:     a,
		ctx:            ctx,
		loadbalancerId: loadbalancerId,
	}
}

// Execute executes the request
//
//	@return LoadbalancerShowResponse
func (a *LoadbalancerV1LoadbalancersApiAPIService) SetLoadbalancerExecute(r LoadbalancerV1LoadbalancersApiAPISetLoadbalancerRequest) (*LoadbalancerShowResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LoadbalancerShowResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/loadbalancers/{loadbalancer_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"loadbalancer_id"+"}", url.PathEscape(parameterValueToString(r.loadbalancerId, "loadbalancerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.loadbalancerUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("loadbalancerUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "loadbalancer 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.loadbalancerUpdateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LoadbalancerV1LoadbalancersApiAPIShowLoadbalancerRequest struct {
	ctx            context.Context
	ApiService     *LoadbalancerV1LoadbalancersApiAPIService
	loadbalancerId string
}

func (r LoadbalancerV1LoadbalancersApiAPIShowLoadbalancerRequest) Execute() (*LoadbalancerShowResponse, *http.Response, error) {
	return r.ApiService.ShowLoadbalancerExecute(r)
}

/*
ShowLoadbalancer ShowLoadbalancer

show Load Balancer

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param loadbalancerId ID
	@return LoadbalancerV1LoadbalancersApiAPIShowLoadbalancerRequest
*/
func (a *LoadbalancerV1LoadbalancersApiAPIService) ShowLoadbalancer(ctx context.Context, loadbalancerId string) LoadbalancerV1LoadbalancersApiAPIShowLoadbalancerRequest {
	return LoadbalancerV1LoadbalancersApiAPIShowLoadbalancerRequest{
		ApiService:     a,
		ctx:            ctx,
		loadbalancerId: loadbalancerId,
	}
}

// Execute executes the request
//
//	@return LoadbalancerShowResponse
func (a *LoadbalancerV1LoadbalancersApiAPIService) ShowLoadbalancerExecute(r LoadbalancerV1LoadbalancersApiAPIShowLoadbalancerRequest) (*LoadbalancerShowResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LoadbalancerShowResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/loadbalancers/{loadbalancer_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"loadbalancer_id"+"}", url.PathEscape(parameterValueToString(r.loadbalancerId, "loadbalancerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "loadbalancer 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
