/*
OSSCP Billing

OSSCP Billing

API version: 1.2.0.0rc5.dev38
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package billing

import (
	"bytes"
	"context"
	scpsdk "github.com/SamsungSDSCloud/terraform-sdk-samsungcloudplatformv2/client"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)

// BillingplanV1PlannedComputeApiAPIService BillingplanV1PlannedComputeApiAPI service
type BillingplanV1PlannedComputeApiAPIService service

type BillingplanV1PlannedComputeApiAPICreatePlannedComputesRequest struct {
	ctx                         context.Context
	ApiService                  *BillingplanV1PlannedComputeApiAPIService
	plannedComputeCreateRequest *PlannedComputeCreateRequest
}

func (r BillingplanV1PlannedComputeApiAPICreatePlannedComputesRequest) PlannedComputeCreateRequest(plannedComputeCreateRequest PlannedComputeCreateRequest) BillingplanV1PlannedComputeApiAPICreatePlannedComputesRequest {
	r.plannedComputeCreateRequest = &plannedComputeCreateRequest
	return r
}

func (r BillingplanV1PlannedComputeApiAPICreatePlannedComputesRequest) Execute() (*PlannedComputeResponse, *http.Response, error) {
	return r.ApiService.CreatePlannedComputesExecute(r)
}

/*
CreatePlannedComputes Create Request Planned Computes

Create request planned compute.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return BillingplanV1PlannedComputeApiAPICreatePlannedComputesRequest
*/
func (a *BillingplanV1PlannedComputeApiAPIService) CreatePlannedComputes(ctx context.Context) BillingplanV1PlannedComputeApiAPICreatePlannedComputesRequest {
	return BillingplanV1PlannedComputeApiAPICreatePlannedComputesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PlannedComputeResponse
func (a *BillingplanV1PlannedComputeApiAPIService) CreatePlannedComputesExecute(r BillingplanV1PlannedComputeApiAPICreatePlannedComputesRequest) (*PlannedComputeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PlannedComputeResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/planned-computes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.plannedComputeCreateRequest == nil {
		return localVarReturnValue, nil, reportError("plannedComputeCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.plannedComputeCreateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["keystone-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user-id"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-User-Id"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["project-id"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Project-Id"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BillingplanV1PlannedComputeApiAPIListContractTypesRequest struct {
	ctx        context.Context
	ApiService *BillingplanV1PlannedComputeApiAPIService
	serviceId  *string
	serverType *string
}

// Service Id
func (r BillingplanV1PlannedComputeApiAPIListContractTypesRequest) ServiceId(serviceId string) BillingplanV1PlannedComputeApiAPIListContractTypesRequest {
	r.serviceId = &serviceId
	return r
}

// Server Type
func (r BillingplanV1PlannedComputeApiAPIListContractTypesRequest) ServerType(serverType string) BillingplanV1PlannedComputeApiAPIListContractTypesRequest {
	r.serverType = &serverType
	return r
}

func (r BillingplanV1PlannedComputeApiAPIListContractTypesRequest) Execute() (*ContractTypeListResponse, *http.Response, error) {
	return r.ApiService.ListContractTypesExecute(r)
}

/*
ListContractTypes List Contract Type

Get Contract Type List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return BillingplanV1PlannedComputeApiAPIListContractTypesRequest
*/
func (a *BillingplanV1PlannedComputeApiAPIService) ListContractTypes(ctx context.Context) BillingplanV1PlannedComputeApiAPIListContractTypesRequest {
	return BillingplanV1PlannedComputeApiAPIListContractTypesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ContractTypeListResponse
func (a *BillingplanV1PlannedComputeApiAPIService) ListContractTypesExecute(r BillingplanV1PlannedComputeApiAPIListContractTypesRequest) (*ContractTypeListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ContractTypeListResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/planned-computes/contract-types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.serviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "service_id", r.serviceId, "form", "")
	}
	if r.serverType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "server_type", r.serverType, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["keystone-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user-id"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-User-Id"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["project-id"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Project-Id"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BillingplanV1PlannedComputeApiAPIListOsTypesRequest struct {
	ctx        context.Context
	ApiService *BillingplanV1PlannedComputeApiAPIService
	serviceId  *string
}

// Service Id
func (r BillingplanV1PlannedComputeApiAPIListOsTypesRequest) ServiceId(serviceId string) BillingplanV1PlannedComputeApiAPIListOsTypesRequest {
	r.serviceId = &serviceId
	return r
}

func (r BillingplanV1PlannedComputeApiAPIListOsTypesRequest) Execute() (*OSTypeListResponse, *http.Response, error) {
	return r.ApiService.ListOsTypesExecute(r)
}

/*
ListOsTypes List OS System

Get Os System List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return BillingplanV1PlannedComputeApiAPIListOsTypesRequest
*/
func (a *BillingplanV1PlannedComputeApiAPIService) ListOsTypes(ctx context.Context) BillingplanV1PlannedComputeApiAPIListOsTypesRequest {
	return BillingplanV1PlannedComputeApiAPIListOsTypesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return OSTypeListResponse
func (a *BillingplanV1PlannedComputeApiAPIService) ListOsTypesExecute(r BillingplanV1PlannedComputeApiAPIListOsTypesRequest) (*OSTypeListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OSTypeListResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/planned-computes/os-types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.serviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "service_id", r.serviceId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["keystone-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user-id"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-User-Id"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["project-id"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Project-Id"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BillingplanV1PlannedComputeApiAPIListPlannedComputeInstancesRequest struct {
	ctx        context.Context
	ApiService *BillingplanV1PlannedComputeApiAPIService
	startDate  *string
	endDate    *string
	serviceId  *string
	osType     *string
	serverType *string
	sort       *string
}

// Start date (YYYY-MM-dd)
func (r BillingplanV1PlannedComputeApiAPIListPlannedComputeInstancesRequest) StartDate(startDate string) BillingplanV1PlannedComputeApiAPIListPlannedComputeInstancesRequest {
	r.startDate = &startDate
	return r
}

// End date (YYYY-MM-dd)
func (r BillingplanV1PlannedComputeApiAPIListPlannedComputeInstancesRequest) EndDate(endDate string) BillingplanV1PlannedComputeApiAPIListPlannedComputeInstancesRequest {
	r.endDate = &endDate
	return r
}

// Service Id
func (r BillingplanV1PlannedComputeApiAPIListPlannedComputeInstancesRequest) ServiceId(serviceId string) BillingplanV1PlannedComputeApiAPIListPlannedComputeInstancesRequest {
	r.serviceId = &serviceId
	return r
}

// OS Type
func (r BillingplanV1PlannedComputeApiAPIListPlannedComputeInstancesRequest) OsType(osType string) BillingplanV1PlannedComputeApiAPIListPlannedComputeInstancesRequest {
	r.osType = &osType
	return r
}

// Server Type
func (r BillingplanV1PlannedComputeApiAPIListPlannedComputeInstancesRequest) ServerType(serverType string) BillingplanV1PlannedComputeApiAPIListPlannedComputeInstancesRequest {
	r.serverType = &serverType
	return r
}

// Sort
func (r BillingplanV1PlannedComputeApiAPIListPlannedComputeInstancesRequest) Sort(sort string) BillingplanV1PlannedComputeApiAPIListPlannedComputeInstancesRequest {
	r.sort = &sort
	return r
}

func (r BillingplanV1PlannedComputeApiAPIListPlannedComputeInstancesRequest) Execute() (*PlannedComputeResourceListResponse, *http.Response, error) {
	return r.ApiService.ListPlannedComputeInstancesExecute(r)
}

/*
ListPlannedComputeInstances List Planned Compute Covered Resource

Get Planned Compute Covered Resource List.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return BillingplanV1PlannedComputeApiAPIListPlannedComputeInstancesRequest
*/
func (a *BillingplanV1PlannedComputeApiAPIService) ListPlannedComputeInstances(ctx context.Context) BillingplanV1PlannedComputeApiAPIListPlannedComputeInstancesRequest {
	return BillingplanV1PlannedComputeApiAPIListPlannedComputeInstancesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PlannedComputeResourceListResponse
func (a *BillingplanV1PlannedComputeApiAPIService) ListPlannedComputeInstancesExecute(r BillingplanV1PlannedComputeApiAPIListPlannedComputeInstancesRequest) (*PlannedComputeResourceListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PlannedComputeResourceListResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/planned-computes/instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.serviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "service_id", r.serviceId, "form", "")
	}
	if r.osType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "os_type", r.osType, "form", "")
	}
	if r.serverType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "server_type", r.serverType, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["keystone-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user-id"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-User-Id"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["project-id"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Project-Id"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BillingplanV1PlannedComputeApiAPIListPlannedComputeServerTypesRequest struct {
	ctx               context.Context
	ApiService        *BillingplanV1PlannedComputeApiAPIService
	serviceId         *string
	currentServerType *string
}

// Service Id
func (r BillingplanV1PlannedComputeApiAPIListPlannedComputeServerTypesRequest) ServiceId(serviceId string) BillingplanV1PlannedComputeApiAPIListPlannedComputeServerTypesRequest {
	r.serviceId = &serviceId
	return r
}

// Server Type
func (r BillingplanV1PlannedComputeApiAPIListPlannedComputeServerTypesRequest) CurrentServerType(currentServerType string) BillingplanV1PlannedComputeApiAPIListPlannedComputeServerTypesRequest {
	r.currentServerType = &currentServerType
	return r
}

func (r BillingplanV1PlannedComputeApiAPIListPlannedComputeServerTypesRequest) Execute() (*ServerTypeListResponse, *http.Response, error) {
	return r.ApiService.ListPlannedComputeServerTypesExecute(r)
}

/*
ListPlannedComputeServerTypes ListServerType

Get Server Type List

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return BillingplanV1PlannedComputeApiAPIListPlannedComputeServerTypesRequest
*/
func (a *BillingplanV1PlannedComputeApiAPIService) ListPlannedComputeServerTypes(ctx context.Context) BillingplanV1PlannedComputeApiAPIListPlannedComputeServerTypesRequest {
	return BillingplanV1PlannedComputeApiAPIListPlannedComputeServerTypesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ServerTypeListResponse
func (a *BillingplanV1PlannedComputeApiAPIService) ListPlannedComputeServerTypesExecute(r BillingplanV1PlannedComputeApiAPIListPlannedComputeServerTypesRequest) (*ServerTypeListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ServerTypeListResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/planned-computes/server-types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.serviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "service_id", r.serviceId, "form", "")
	}
	if r.currentServerType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current_server_type", r.currentServerType, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["keystone-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user-id"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-User-Id"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["project-id"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Project-Id"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BillingplanV1PlannedComputeApiAPIListPlannedComputeServiceTypesRequest struct {
	ctx        context.Context
	ApiService *BillingplanV1PlannedComputeApiAPIService
}

func (r BillingplanV1PlannedComputeApiAPIListPlannedComputeServiceTypesRequest) Execute() (*ProductListResponse, *http.Response, error) {
	return r.ApiService.ListPlannedComputeServiceTypesExecute(r)
}

/*
ListPlannedComputeServiceTypes ListServiceType

Get Service Type List

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return BillingplanV1PlannedComputeApiAPIListPlannedComputeServiceTypesRequest
*/
func (a *BillingplanV1PlannedComputeApiAPIService) ListPlannedComputeServiceTypes(ctx context.Context) BillingplanV1PlannedComputeApiAPIListPlannedComputeServiceTypesRequest {
	return BillingplanV1PlannedComputeApiAPIListPlannedComputeServiceTypesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ProductListResponse
func (a *BillingplanV1PlannedComputeApiAPIService) ListPlannedComputeServiceTypesExecute(r BillingplanV1PlannedComputeApiAPIListPlannedComputeServiceTypesRequest) (*ProductListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ProductListResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/planned-computes/service-types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["keystone-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user-id"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-User-Id"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["project-id"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Project-Id"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BillingplanV1PlannedComputeApiAPIListPlannedComputesRequest struct {
	ctx              context.Context
	ApiService       *BillingplanV1PlannedComputeApiAPIService
	limit            *int32
	page             *int32
	startDate        *string
	endDate          *string
	serverType       *string
	contractId       *string
	contractType     *[]*string
	nextContractType *[]*string
	serviceId        *[]*string
	osType           *[]*string
	state            *[]*string
	createdBy        *string
	modifiedBy       *string
	sort             *string
}

// LIMIT
func (r BillingplanV1PlannedComputeApiAPIListPlannedComputesRequest) Limit(limit int32) BillingplanV1PlannedComputeApiAPIListPlannedComputesRequest {
	r.limit = &limit
	return r
}

// Page
func (r BillingplanV1PlannedComputeApiAPIListPlannedComputesRequest) Page(page int32) BillingplanV1PlannedComputeApiAPIListPlannedComputesRequest {
	r.page = &page
	return r
}

// Start date (YYYY-MM-dd)
func (r BillingplanV1PlannedComputeApiAPIListPlannedComputesRequest) StartDate(startDate string) BillingplanV1PlannedComputeApiAPIListPlannedComputesRequest {
	r.startDate = &startDate
	return r
}

// End date (YYYY-MM-dd)
func (r BillingplanV1PlannedComputeApiAPIListPlannedComputesRequest) EndDate(endDate string) BillingplanV1PlannedComputeApiAPIListPlannedComputesRequest {
	r.endDate = &endDate
	return r
}

// Server Type
func (r BillingplanV1PlannedComputeApiAPIListPlannedComputesRequest) ServerType(serverType string) BillingplanV1PlannedComputeApiAPIListPlannedComputesRequest {
	r.serverType = &serverType
	return r
}

// Contract Id
func (r BillingplanV1PlannedComputeApiAPIListPlannedComputesRequest) ContractId(contractId string) BillingplanV1PlannedComputeApiAPIListPlannedComputesRequest {
	r.contractId = &contractId
	return r
}

// Contract Type
func (r BillingplanV1PlannedComputeApiAPIListPlannedComputesRequest) ContractType(contractType []*string) BillingplanV1PlannedComputeApiAPIListPlannedComputesRequest {
	r.contractType = &contractType
	return r
}

// Next Contract Type
func (r BillingplanV1PlannedComputeApiAPIListPlannedComputesRequest) NextContractType(nextContractType []*string) BillingplanV1PlannedComputeApiAPIListPlannedComputesRequest {
	r.nextContractType = &nextContractType
	return r
}

// Service Id
func (r BillingplanV1PlannedComputeApiAPIListPlannedComputesRequest) ServiceId(serviceId []*string) BillingplanV1PlannedComputeApiAPIListPlannedComputesRequest {
	r.serviceId = &serviceId
	return r
}

// OS Type
func (r BillingplanV1PlannedComputeApiAPIListPlannedComputesRequest) OsType(osType []*string) BillingplanV1PlannedComputeApiAPIListPlannedComputesRequest {
	r.osType = &osType
	return r
}

// Planned Compute State
func (r BillingplanV1PlannedComputeApiAPIListPlannedComputesRequest) State(state []*string) BillingplanV1PlannedComputeApiAPIListPlannedComputesRequest {
	r.state = &state
	return r
}

// Created by
func (r BillingplanV1PlannedComputeApiAPIListPlannedComputesRequest) CreatedBy(createdBy string) BillingplanV1PlannedComputeApiAPIListPlannedComputesRequest {
	r.createdBy = &createdBy
	return r
}

// Modified by
func (r BillingplanV1PlannedComputeApiAPIListPlannedComputesRequest) ModifiedBy(modifiedBy string) BillingplanV1PlannedComputeApiAPIListPlannedComputesRequest {
	r.modifiedBy = &modifiedBy
	return r
}

// Sort
func (r BillingplanV1PlannedComputeApiAPIListPlannedComputesRequest) Sort(sort string) BillingplanV1PlannedComputeApiAPIListPlannedComputesRequest {
	r.sort = &sort
	return r
}

func (r BillingplanV1PlannedComputeApiAPIListPlannedComputesRequest) Execute() (*PlannedComputeListResponse, *http.Response, error) {
	return r.ApiService.ListPlannedComputesExecute(r)
}

/*
ListPlannedComputes ListPlannedComputes

Get planned compute list.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return BillingplanV1PlannedComputeApiAPIListPlannedComputesRequest
*/
func (a *BillingplanV1PlannedComputeApiAPIService) ListPlannedComputes(ctx context.Context) BillingplanV1PlannedComputeApiAPIListPlannedComputesRequest {
	return BillingplanV1PlannedComputeApiAPIListPlannedComputesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PlannedComputeListResponse
func (a *BillingplanV1PlannedComputeApiAPIService) ListPlannedComputesExecute(r BillingplanV1PlannedComputeApiAPIListPlannedComputesRequest) (*PlannedComputeListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PlannedComputeListResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/planned-computes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.serverType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "server_type", r.serverType, "form", "")
	}
	if r.contractId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contract_id", r.contractId, "form", "")
	}
	if r.contractType != nil {
		t := *r.contractType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contract_type", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contract_type", t, "form", "multi")
		}
	}
	if r.nextContractType != nil {
		t := *r.nextContractType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "next_contract_type", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "next_contract_type", t, "form", "multi")
		}
	}
	if r.serviceId != nil {
		t := *r.serviceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "service_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "service_id", t, "form", "multi")
		}
	}
	if r.osType != nil {
		t := *r.osType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "os_type", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "os_type", t, "form", "multi")
		}
	}
	if r.state != nil {
		t := *r.state
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "state", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "state", t, "form", "multi")
		}
	}
	if r.createdBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by", r.createdBy, "form", "")
	}
	if r.modifiedBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by", r.modifiedBy, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["keystone-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user-id"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-User-Id"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["project-id"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Project-Id"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BillingplanV1PlannedComputeApiAPIShowCancellationFeeRequest struct {
	ctx                    context.Context
	ApiService             *BillingplanV1PlannedComputeApiAPIService
	cancellationFeeRequest *CancellationFeeRequest
}

func (r BillingplanV1PlannedComputeApiAPIShowCancellationFeeRequest) CancellationFeeRequest(cancellationFeeRequest CancellationFeeRequest) BillingplanV1PlannedComputeApiAPIShowCancellationFeeRequest {
	r.cancellationFeeRequest = &cancellationFeeRequest
	return r
}

func (r BillingplanV1PlannedComputeApiAPIShowCancellationFeeRequest) Execute() (*CancellationFeeResponse, *http.Response, error) {
	return r.ApiService.ShowCancellationFeeExecute(r)
}

/*
ShowCancellationFee GetTerminationInfo

Get Contract Termination Info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return BillingplanV1PlannedComputeApiAPIShowCancellationFeeRequest
*/
func (a *BillingplanV1PlannedComputeApiAPIService) ShowCancellationFee(ctx context.Context) BillingplanV1PlannedComputeApiAPIShowCancellationFeeRequest {
	return BillingplanV1PlannedComputeApiAPIShowCancellationFeeRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CancellationFeeResponse
func (a *BillingplanV1PlannedComputeApiAPIService) ShowCancellationFeeExecute(r BillingplanV1PlannedComputeApiAPIShowCancellationFeeRequest) (*CancellationFeeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CancellationFeeResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/planned-computes/cancellation-fee"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cancellationFeeRequest == nil {
		return localVarReturnValue, nil, reportError("cancellationFeeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cancellationFeeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["keystone-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user-id"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-User-Id"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["project-id"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Project-Id"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BillingplanV1PlannedComputeApiAPIShowPlannedComputeRequest struct {
	ctx              context.Context
	ApiService       *BillingplanV1PlannedComputeApiAPIService
	plannedComputeId string
}

func (r BillingplanV1PlannedComputeApiAPIShowPlannedComputeRequest) Execute() (*PlannedComputeResponse, *http.Response, error) {
	return r.ApiService.ShowPlannedComputeExecute(r)
}

/*
ShowPlannedCompute Get Planned Compute

Get planned compute.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param plannedComputeId Planned Compute Id
	@return BillingplanV1PlannedComputeApiAPIShowPlannedComputeRequest
*/
func (a *BillingplanV1PlannedComputeApiAPIService) ShowPlannedCompute(ctx context.Context, plannedComputeId string) BillingplanV1PlannedComputeApiAPIShowPlannedComputeRequest {
	return BillingplanV1PlannedComputeApiAPIShowPlannedComputeRequest{
		ApiService:       a,
		ctx:              ctx,
		plannedComputeId: plannedComputeId,
	}
}

// Execute executes the request
//
//	@return PlannedComputeResponse
func (a *BillingplanV1PlannedComputeApiAPIService) ShowPlannedComputeExecute(r BillingplanV1PlannedComputeApiAPIShowPlannedComputeRequest) (*PlannedComputeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PlannedComputeResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/planned-computes/{planned_compute_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"planned_compute_id"+"}", url.PathEscape(parameterValueToString(r.plannedComputeId, "plannedComputeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["keystone-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user-id"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-User-Id"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["project-id"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Project-Id"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BillingplanV1PlannedComputeApiAPIUpdatePlannedComputeRequest struct {
	ctx                         context.Context
	ApiService                  *BillingplanV1PlannedComputeApiAPIService
	plannedComputeId            string
	plannedComputeChangeRequest *PlannedComputeChangeRequest
}

func (r BillingplanV1PlannedComputeApiAPIUpdatePlannedComputeRequest) PlannedComputeChangeRequest(plannedComputeChangeRequest PlannedComputeChangeRequest) BillingplanV1PlannedComputeApiAPIUpdatePlannedComputeRequest {
	r.plannedComputeChangeRequest = &plannedComputeChangeRequest
	return r
}

func (r BillingplanV1PlannedComputeApiAPIUpdatePlannedComputeRequest) Execute() (*PlannedComputeResponse, *http.Response, error) {
	return r.ApiService.UpdatePlannedComputeExecute(r)
}

/*
UpdatePlannedCompute Change Request Planned Compute

Change action request planned compute.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param plannedComputeId Planned Compute Id
	@return BillingplanV1PlannedComputeApiAPIUpdatePlannedComputeRequest
*/
func (a *BillingplanV1PlannedComputeApiAPIService) UpdatePlannedCompute(ctx context.Context, plannedComputeId string) BillingplanV1PlannedComputeApiAPIUpdatePlannedComputeRequest {
	return BillingplanV1PlannedComputeApiAPIUpdatePlannedComputeRequest{
		ApiService:       a,
		ctx:              ctx,
		plannedComputeId: plannedComputeId,
	}
}

// Execute executes the request
//
//	@return PlannedComputeResponse
func (a *BillingplanV1PlannedComputeApiAPIService) UpdatePlannedComputeExecute(r BillingplanV1PlannedComputeApiAPIUpdatePlannedComputeRequest) (*PlannedComputeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PlannedComputeResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/planned-computes/{planned_compute_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"planned_compute_id"+"}", url.PathEscape(parameterValueToString(r.plannedComputeId, "plannedComputeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.plannedComputeChangeRequest == nil {
		return localVarReturnValue, nil, reportError("plannedComputeChangeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.plannedComputeChangeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["keystone-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user-id"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-User-Id"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["project-id"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Project-Id"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
