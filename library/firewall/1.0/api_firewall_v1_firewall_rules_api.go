/*
SCP Network Service

SCP Network Service

API version: 0.0.1.dev6882
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package firewall

import (
	"bytes"
	"context"
	scpsdk "github.com/SamsungSDSCloud/terraform-sdk-samsungcloudplatformv2/client"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// FirewallV1FirewallRulesApiAPIService FirewallV1FirewallRulesApiAPI service
type FirewallV1FirewallRulesApiAPIService service

type FirewallV1FirewallRulesApiAPICreateFirewallRuleRequest struct {
	ctx                             context.Context
	ApiService                      *FirewallV1FirewallRulesApiAPIService
	firewallRuleCreateSingleRequest *FirewallRuleCreateSingleRequest
}

func (r FirewallV1FirewallRulesApiAPICreateFirewallRuleRequest) FirewallRuleCreateSingleRequest(firewallRuleCreateSingleRequest FirewallRuleCreateSingleRequest) FirewallV1FirewallRulesApiAPICreateFirewallRuleRequest {
	r.firewallRuleCreateSingleRequest = &firewallRuleCreateSingleRequest
	return r
}

func (r FirewallV1FirewallRulesApiAPICreateFirewallRuleRequest) Execute() (*FirewallRuleShowResponse, *http.Response, error) {
	return r.ApiService.CreateFirewallRuleExecute(r)
}

/*
CreateFirewallRule Create Firewall Rule

Create firewall rule.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FirewallV1FirewallRulesApiAPICreateFirewallRuleRequest
*/
func (a *FirewallV1FirewallRulesApiAPIService) CreateFirewallRule(ctx context.Context) FirewallV1FirewallRulesApiAPICreateFirewallRuleRequest {
	return FirewallV1FirewallRulesApiAPICreateFirewallRuleRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FirewallRuleShowResponse
func (a *FirewallV1FirewallRulesApiAPIService) CreateFirewallRuleExecute(r FirewallV1FirewallRulesApiAPICreateFirewallRuleRequest) (*FirewallRuleShowResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FirewallRuleShowResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/firewalls/rules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.firewallRuleCreateSingleRequest == nil {
		return localVarReturnValue, nil, reportError("firewallRuleCreateSingleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "firewall 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.firewallRuleCreateSingleRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FirewallV1FirewallRulesApiAPICreateFirewallRuleBulkRequest struct {
	ctx                           context.Context
	ApiService                    *FirewallV1FirewallRulesApiAPIService
	firewallRuleCreateBulkRequest *FirewallRuleCreateBulkRequest
}

func (r FirewallV1FirewallRulesApiAPICreateFirewallRuleBulkRequest) FirewallRuleCreateBulkRequest(firewallRuleCreateBulkRequest FirewallRuleCreateBulkRequest) FirewallV1FirewallRulesApiAPICreateFirewallRuleBulkRequest {
	r.firewallRuleCreateBulkRequest = &firewallRuleCreateBulkRequest
	return r
}

func (r FirewallV1FirewallRulesApiAPICreateFirewallRuleBulkRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateFirewallRuleBulkExecute(r)
}

/*
CreateFirewallRuleBulk Create Firewall Rule Bulk

Create firewall rule bulk.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FirewallV1FirewallRulesApiAPICreateFirewallRuleBulkRequest
*/
func (a *FirewallV1FirewallRulesApiAPIService) CreateFirewallRuleBulk(ctx context.Context) FirewallV1FirewallRulesApiAPICreateFirewallRuleBulkRequest {
	return FirewallV1FirewallRulesApiAPICreateFirewallRuleBulkRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *FirewallV1FirewallRulesApiAPIService) CreateFirewallRuleBulkExecute(r FirewallV1FirewallRulesApiAPICreateFirewallRuleBulkRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return nil, err
		}
	}

	localVarPath := basePath + "/v1/firewalls/rules/bulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.firewallRuleCreateBulkRequest == nil {
		return nil, reportError("firewallRuleCreateBulkRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	localVarHeaderParams["Scp-API-Version"] = "firewall 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.firewallRuleCreateBulkRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FirewallV1FirewallRulesApiAPIDeleteFirewallRuleRequest struct {
	ctx            context.Context
	ApiService     *FirewallV1FirewallRulesApiAPIService
	firewallRuleId string
}

func (r FirewallV1FirewallRulesApiAPIDeleteFirewallRuleRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteFirewallRuleExecute(r)
}

/*
DeleteFirewallRule Delete Firewall Rule

Delete firewall rule.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param firewallRuleId Firewall Rule ID
	@return FirewallV1FirewallRulesApiAPIDeleteFirewallRuleRequest
*/
func (a *FirewallV1FirewallRulesApiAPIService) DeleteFirewallRule(ctx context.Context, firewallRuleId string) FirewallV1FirewallRulesApiAPIDeleteFirewallRuleRequest {
	return FirewallV1FirewallRulesApiAPIDeleteFirewallRuleRequest{
		ApiService:     a,
		ctx:            ctx,
		firewallRuleId: firewallRuleId,
	}
}

// Execute executes the request
func (a *FirewallV1FirewallRulesApiAPIService) DeleteFirewallRuleExecute(r FirewallV1FirewallRulesApiAPIDeleteFirewallRuleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return nil, err
		}
	}

	localVarPath := basePath + "/v1/firewalls/rules/{firewall_rule_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"firewall_rule_id"+"}", url.PathEscape(parameterValueToString(r.firewallRuleId, "firewallRuleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	localVarHeaderParams["Scp-API-Version"] = "firewall 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FirewallV1FirewallRulesApiAPIDeleteFirewallRuleBulkRequest struct {
	ctx                           context.Context
	ApiService                    *FirewallV1FirewallRulesApiAPIService
	firewallRuleDeleteBulkRequest *FirewallRuleDeleteBulkRequest
}

func (r FirewallV1FirewallRulesApiAPIDeleteFirewallRuleBulkRequest) FirewallRuleDeleteBulkRequest(firewallRuleDeleteBulkRequest FirewallRuleDeleteBulkRequest) FirewallV1FirewallRulesApiAPIDeleteFirewallRuleBulkRequest {
	r.firewallRuleDeleteBulkRequest = &firewallRuleDeleteBulkRequest
	return r
}

func (r FirewallV1FirewallRulesApiAPIDeleteFirewallRuleBulkRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteFirewallRuleBulkExecute(r)
}

/*
DeleteFirewallRuleBulk Delete Firewall Rule Bulk

Delete firewall rule bulk.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FirewallV1FirewallRulesApiAPIDeleteFirewallRuleBulkRequest
*/
func (a *FirewallV1FirewallRulesApiAPIService) DeleteFirewallRuleBulk(ctx context.Context) FirewallV1FirewallRulesApiAPIDeleteFirewallRuleBulkRequest {
	return FirewallV1FirewallRulesApiAPIDeleteFirewallRuleBulkRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *FirewallV1FirewallRulesApiAPIService) DeleteFirewallRuleBulkExecute(r FirewallV1FirewallRulesApiAPIDeleteFirewallRuleBulkRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return nil, err
		}
	}

	localVarPath := basePath + "/v1/firewalls/rules/bulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.firewallRuleDeleteBulkRequest == nil {
		return nil, reportError("firewallRuleDeleteBulkRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "firewall 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.firewallRuleDeleteBulkRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ValidationErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.ErrorMessage = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.ErrorModel = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FirewallV1FirewallRulesApiAPIDownloadFirewallRulesRequest struct {
	ctx        context.Context
	ApiService *FirewallV1FirewallRulesApiAPIService
	firewallId *string
}

// Firewall ID
func (r FirewallV1FirewallRulesApiAPIDownloadFirewallRulesRequest) FirewallId(firewallId string) FirewallV1FirewallRulesApiAPIDownloadFirewallRulesRequest {
	r.firewallId = &firewallId
	return r
}

func (r FirewallV1FirewallRulesApiAPIDownloadFirewallRulesRequest) Execute() (*http.Response, error) {
	return r.ApiService.DownloadFirewallRulesExecute(r)
}

/*
DownloadFirewallRules Download Firewall Rules

Download firewall rule list.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FirewallV1FirewallRulesApiAPIDownloadFirewallRulesRequest
*/
func (a *FirewallV1FirewallRulesApiAPIService) DownloadFirewallRules(ctx context.Context) FirewallV1FirewallRulesApiAPIDownloadFirewallRulesRequest {
	return FirewallV1FirewallRulesApiAPIDownloadFirewallRulesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *FirewallV1FirewallRulesApiAPIService) DownloadFirewallRulesExecute(r FirewallV1FirewallRulesApiAPIDownloadFirewallRulesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return nil, err
		}
	}

	localVarPath := basePath + "/v1/firewalls/rules/downloads"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.firewallId == nil {
		return nil, reportError("firewallId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "firewall_id", r.firewallId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	localVarHeaderParams["Scp-API-Version"] = "firewall 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FirewallV1FirewallRulesApiAPIListFirewallRulesRequest struct {
	ctx         context.Context
	ApiService  *FirewallV1FirewallRulesApiAPIService
	firewallId  *string
	size        *int32
	page        *int32
	sort        *string
	srcIp       *string
	dstIp       *string
	description *string
	state       *[]FirewallRuleState
	status      *FirewallStatusType
	fetchAll    *bool
}

// Firewall ID
func (r FirewallV1FirewallRulesApiAPIListFirewallRulesRequest) FirewallId(firewallId string) FirewallV1FirewallRulesApiAPIListFirewallRulesRequest {
	r.firewallId = &firewallId
	return r
}

// size
func (r FirewallV1FirewallRulesApiAPIListFirewallRulesRequest) Size(size int32) FirewallV1FirewallRulesApiAPIListFirewallRulesRequest {
	r.size = &size
	return r
}

// page
func (r FirewallV1FirewallRulesApiAPIListFirewallRulesRequest) Page(page int32) FirewallV1FirewallRulesApiAPIListFirewallRulesRequest {
	r.page = &page
	return r
}

// sort
func (r FirewallV1FirewallRulesApiAPIListFirewallRulesRequest) Sort(sort string) FirewallV1FirewallRulesApiAPIListFirewallRulesRequest {
	r.sort = &sort
	return r
}

// Source IP
func (r FirewallV1FirewallRulesApiAPIListFirewallRulesRequest) SrcIp(srcIp string) FirewallV1FirewallRulesApiAPIListFirewallRulesRequest {
	r.srcIp = &srcIp
	return r
}

// Destination IP
func (r FirewallV1FirewallRulesApiAPIListFirewallRulesRequest) DstIp(dstIp string) FirewallV1FirewallRulesApiAPIListFirewallRulesRequest {
	r.dstIp = &dstIp
	return r
}

// Firewall Rule Description
func (r FirewallV1FirewallRulesApiAPIListFirewallRulesRequest) Description(description string) FirewallV1FirewallRulesApiAPIListFirewallRulesRequest {
	r.description = &description
	return r
}

// Firewall Rule State
func (r FirewallV1FirewallRulesApiAPIListFirewallRulesRequest) State(state []FirewallRuleState) FirewallV1FirewallRulesApiAPIListFirewallRulesRequest {
	r.state = &state
	return r
}

// Firewall Rule Status
func (r FirewallV1FirewallRulesApiAPIListFirewallRulesRequest) Status(status FirewallStatusType) FirewallV1FirewallRulesApiAPIListFirewallRulesRequest {
	r.status = &status
	return r
}

// Firewall Rule Fetch ALL
func (r FirewallV1FirewallRulesApiAPIListFirewallRulesRequest) FetchAll(fetchAll bool) FirewallV1FirewallRulesApiAPIListFirewallRulesRequest {
	r.fetchAll = &fetchAll
	return r
}

func (r FirewallV1FirewallRulesApiAPIListFirewallRulesRequest) Execute() (*FirewallRuleListResponse, *http.Response, error) {
	return r.ApiService.ListFirewallRulesExecute(r)
}

/*
ListFirewallRules List Firewall Rules

Get firewall rule list.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FirewallV1FirewallRulesApiAPIListFirewallRulesRequest
*/
func (a *FirewallV1FirewallRulesApiAPIService) ListFirewallRules(ctx context.Context) FirewallV1FirewallRulesApiAPIListFirewallRulesRequest {
	return FirewallV1FirewallRulesApiAPIListFirewallRulesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FirewallRuleListResponse
func (a *FirewallV1FirewallRulesApiAPIService) ListFirewallRulesExecute(r FirewallV1FirewallRulesApiAPIListFirewallRulesRequest) (*FirewallRuleListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FirewallRuleListResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/firewalls/rules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.firewallId == nil {
		return localVarReturnValue, nil, reportError("firewallId is required and must be specified")
	}

	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "firewall_id", r.firewallId, "form", "")
	if r.srcIp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "src_ip", r.srcIp, "form", "")
	}
	if r.dstIp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dst_ip", r.dstIp, "form", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.state != nil {
		t := *r.state
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "state", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "state", t, "form", "multi")
		}
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.fetchAll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetch_all", r.fetchAll, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "firewall 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FirewallV1FirewallRulesApiAPISetFirewallRuleRequest struct {
	ctx                    context.Context
	ApiService             *FirewallV1FirewallRulesApiAPIService
	firewallRuleId         string
	firewallRuleSetRequest *FirewallRuleSetRequest
}

func (r FirewallV1FirewallRulesApiAPISetFirewallRuleRequest) FirewallRuleSetRequest(firewallRuleSetRequest FirewallRuleSetRequest) FirewallV1FirewallRulesApiAPISetFirewallRuleRequest {
	r.firewallRuleSetRequest = &firewallRuleSetRequest
	return r
}

func (r FirewallV1FirewallRulesApiAPISetFirewallRuleRequest) Execute() (*FirewallRuleShowResponse, *http.Response, error) {
	return r.ApiService.SetFirewallRuleExecute(r)
}

/*
SetFirewallRule Set Firewall Rule

Set firewall rule.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param firewallRuleId Firewall Rule ID
	@return FirewallV1FirewallRulesApiAPISetFirewallRuleRequest
*/
func (a *FirewallV1FirewallRulesApiAPIService) SetFirewallRule(ctx context.Context, firewallRuleId string) FirewallV1FirewallRulesApiAPISetFirewallRuleRequest {
	return FirewallV1FirewallRulesApiAPISetFirewallRuleRequest{
		ApiService:     a,
		ctx:            ctx,
		firewallRuleId: firewallRuleId,
	}
}

// Execute executes the request
//
//	@return FirewallRuleShowResponse
func (a *FirewallV1FirewallRulesApiAPIService) SetFirewallRuleExecute(r FirewallV1FirewallRulesApiAPISetFirewallRuleRequest) (*FirewallRuleShowResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FirewallRuleShowResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/firewalls/rules/{firewall_rule_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"firewall_rule_id"+"}", url.PathEscape(parameterValueToString(r.firewallRuleId, "firewallRuleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.firewallRuleSetRequest == nil {
		return localVarReturnValue, nil, reportError("firewallRuleSetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "firewall 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.firewallRuleSetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FirewallV1FirewallRulesApiAPISetFirewallRuleBulkRequest struct {
	ctx                           context.Context
	ApiService                    *FirewallV1FirewallRulesApiAPIService
	firewallRuleUpdateBulkRequest *FirewallRuleUpdateBulkRequest
}

func (r FirewallV1FirewallRulesApiAPISetFirewallRuleBulkRequest) FirewallRuleUpdateBulkRequest(firewallRuleUpdateBulkRequest FirewallRuleUpdateBulkRequest) FirewallV1FirewallRulesApiAPISetFirewallRuleBulkRequest {
	r.firewallRuleUpdateBulkRequest = &firewallRuleUpdateBulkRequest
	return r
}

func (r FirewallV1FirewallRulesApiAPISetFirewallRuleBulkRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetFirewallRuleBulkExecute(r)
}

/*
SetFirewallRuleBulk Set Firewall Rule Bulk

Set firewall rule bulk.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FirewallV1FirewallRulesApiAPISetFirewallRuleBulkRequest
*/
func (a *FirewallV1FirewallRulesApiAPIService) SetFirewallRuleBulk(ctx context.Context) FirewallV1FirewallRulesApiAPISetFirewallRuleBulkRequest {
	return FirewallV1FirewallRulesApiAPISetFirewallRuleBulkRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *FirewallV1FirewallRulesApiAPIService) SetFirewallRuleBulkExecute(r FirewallV1FirewallRulesApiAPISetFirewallRuleBulkRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return nil, err
		}
	}

	localVarPath := basePath + "/v1/firewalls/rules/bulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.firewallRuleUpdateBulkRequest == nil {
		return nil, reportError("firewallRuleUpdateBulkRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	localVarHeaderParams["Scp-API-Version"] = "firewall 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.firewallRuleUpdateBulkRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FirewallV1FirewallRulesApiAPISetFirewallRuleOrderRequest struct {
	ctx                         context.Context
	ApiService                  *FirewallV1FirewallRulesApiAPIService
	firewallRuleId              string
	firewallRuleSetOrderRequest *FirewallRuleSetOrderRequest
}

func (r FirewallV1FirewallRulesApiAPISetFirewallRuleOrderRequest) FirewallRuleSetOrderRequest(firewallRuleSetOrderRequest FirewallRuleSetOrderRequest) FirewallV1FirewallRulesApiAPISetFirewallRuleOrderRequest {
	r.firewallRuleSetOrderRequest = &firewallRuleSetOrderRequest
	return r
}

func (r FirewallV1FirewallRulesApiAPISetFirewallRuleOrderRequest) Execute() (*FirewallRuleShowResponse, *http.Response, error) {
	return r.ApiService.SetFirewallRuleOrderExecute(r)
}

/*
SetFirewallRuleOrder Set Firewall Rule Order

Set firewall rule order.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param firewallRuleId Firewall Rule ID
	@return FirewallV1FirewallRulesApiAPISetFirewallRuleOrderRequest
*/
func (a *FirewallV1FirewallRulesApiAPIService) SetFirewallRuleOrder(ctx context.Context, firewallRuleId string) FirewallV1FirewallRulesApiAPISetFirewallRuleOrderRequest {
	return FirewallV1FirewallRulesApiAPISetFirewallRuleOrderRequest{
		ApiService:     a,
		ctx:            ctx,
		firewallRuleId: firewallRuleId,
	}
}

// Execute executes the request
//
//	@return FirewallRuleShowResponse
func (a *FirewallV1FirewallRulesApiAPIService) SetFirewallRuleOrderExecute(r FirewallV1FirewallRulesApiAPISetFirewallRuleOrderRequest) (*FirewallRuleShowResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FirewallRuleShowResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/firewalls/rules/{firewall_rule_id}/order"
	localVarPath = strings.Replace(localVarPath, "{"+"firewall_rule_id"+"}", url.PathEscape(parameterValueToString(r.firewallRuleId, "firewallRuleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.firewallRuleSetOrderRequest == nil {
		return localVarReturnValue, nil, reportError("firewallRuleSetOrderRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "firewall 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.firewallRuleSetOrderRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FirewallV1FirewallRulesApiAPIShowFirewallRuleRequest struct {
	ctx            context.Context
	ApiService     *FirewallV1FirewallRulesApiAPIService
	firewallRuleId string
}

func (r FirewallV1FirewallRulesApiAPIShowFirewallRuleRequest) Execute() (*FirewallRuleShowResponse, *http.Response, error) {
	return r.ApiService.ShowFirewallRuleExecute(r)
}

/*
ShowFirewallRule Show Firewall Rule

Show firewall rule.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param firewallRuleId Firewall Rule ID
	@return FirewallV1FirewallRulesApiAPIShowFirewallRuleRequest
*/
func (a *FirewallV1FirewallRulesApiAPIService) ShowFirewallRule(ctx context.Context, firewallRuleId string) FirewallV1FirewallRulesApiAPIShowFirewallRuleRequest {
	return FirewallV1FirewallRulesApiAPIShowFirewallRuleRequest{
		ApiService:     a,
		ctx:            ctx,
		firewallRuleId: firewallRuleId,
	}
}

// Execute executes the request
//
//	@return FirewallRuleShowResponse
func (a *FirewallV1FirewallRulesApiAPIService) ShowFirewallRuleExecute(r FirewallV1FirewallRulesApiAPIShowFirewallRuleRequest) (*FirewallRuleShowResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FirewallRuleShowResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/firewalls/rules/{firewall_rule_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"firewall_rule_id"+"}", url.PathEscape(parameterValueToString(r.firewallRuleId, "firewallRuleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "firewall 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ValidationErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.ErrorMessage = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.ErrorModel = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
