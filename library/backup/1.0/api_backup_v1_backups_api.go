/*
OSSCP backup Project

OSSCP backup Project

API version: 0.0.1.dev566
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package backup

import (
	"bytes"
	"context"
	scpsdk "github.com/SamsungSDSCloud/terraform-sdk-samsungcloudplatformv2/client"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// BackupV1BackupsApiAPIService BackupV1BackupsApiAPI service
type BackupV1BackupsApiAPIService service

type BackupV1BackupsApiAPICheckBackupNameDuplicateRequest struct {
	ctx        context.Context
	ApiService *BackupV1BackupsApiAPIService
	backupName *string
}

// Backup name
func (r BackupV1BackupsApiAPICheckBackupNameDuplicateRequest) BackupName(backupName string) BackupV1BackupsApiAPICheckBackupNameDuplicateRequest {
	r.backupName = &backupName
	return r
}

func (r BackupV1BackupsApiAPICheckBackupNameDuplicateRequest) Execute() (*BackupNameDuplicateResponse, *http.Response, error) {
	return r.ApiService.CheckBackupNameDuplicateExecute(r)
}

/*
CheckBackupNameDuplicate Check Backup Name Duplicate

Check for duplicate backup names.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return BackupV1BackupsApiAPICheckBackupNameDuplicateRequest
*/
func (a *BackupV1BackupsApiAPIService) CheckBackupNameDuplicate(ctx context.Context) BackupV1BackupsApiAPICheckBackupNameDuplicateRequest {
	return BackupV1BackupsApiAPICheckBackupNameDuplicateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return BackupNameDuplicateResponse
func (a *BackupV1BackupsApiAPIService) CheckBackupNameDuplicateExecute(r BackupV1BackupsApiAPICheckBackupNameDuplicateRequest) (*BackupNameDuplicateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BackupNameDuplicateResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/backups/check-name-duplication"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.backupName == nil {
		return localVarReturnValue, nil, reportError("backupName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "backup_name", r.backupName, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "backup 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ValidationErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.ErrorMessage = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.ErrorModel = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BackupV1BackupsApiAPICreateBackupRequest struct {
	ctx                 context.Context
	ApiService          *BackupV1BackupsApiAPIService
	backupCreateRequest *BackupCreateRequest
}

func (r BackupV1BackupsApiAPICreateBackupRequest) BackupCreateRequest(backupCreateRequest BackupCreateRequest) BackupV1BackupsApiAPICreateBackupRequest {
	r.backupCreateRequest = &backupCreateRequest
	return r
}

func (r BackupV1BackupsApiAPICreateBackupRequest) Execute() (*SyncResponse, *http.Response, error) {
	return r.ApiService.CreateBackupExecute(r)
}

/*
CreateBackup Create Backup

Create a Backup.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return BackupV1BackupsApiAPICreateBackupRequest
*/
func (a *BackupV1BackupsApiAPIService) CreateBackup(ctx context.Context) BackupV1BackupsApiAPICreateBackupRequest {
	return BackupV1BackupsApiAPICreateBackupRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SyncResponse
func (a *BackupV1BackupsApiAPIService) CreateBackupExecute(r BackupV1BackupsApiAPICreateBackupRequest) (*SyncResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SyncResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/backups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.backupCreateRequest == nil {
		return localVarReturnValue, nil, reportError("backupCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "backup 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.backupCreateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ValidationErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.ErrorMessage = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.ErrorModel = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BackupV1BackupsApiAPIDeleteBackupRequest struct {
	ctx        context.Context
	ApiService *BackupV1BackupsApiAPIService
	backupId   string
}

func (r BackupV1BackupsApiAPIDeleteBackupRequest) Execute() (*SyncResponse, *http.Response, error) {
	return r.ApiService.DeleteBackupExecute(r)
}

/*
DeleteBackup Delete Backup

Terminate the Backup.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param backupId Backup ID
	@return BackupV1BackupsApiAPIDeleteBackupRequest
*/
func (a *BackupV1BackupsApiAPIService) DeleteBackup(ctx context.Context, backupId string) BackupV1BackupsApiAPIDeleteBackupRequest {
	return BackupV1BackupsApiAPIDeleteBackupRequest{
		ApiService: a,
		ctx:        ctx,
		backupId:   backupId,
	}
}

// Execute executes the request
//
//	@return SyncResponse
func (a *BackupV1BackupsApiAPIService) DeleteBackupExecute(r BackupV1BackupsApiAPIDeleteBackupRequest) (*SyncResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SyncResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/backups/{backup_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"backup_id"+"}", url.PathEscape(parameterValueToString(r.backupId, "backupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "backup 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ValidationErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.ErrorMessage = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.ErrorModel = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BackupV1BackupsApiAPIGetBackupTargetListRequest struct {
	ctx            context.Context
	ApiService     *BackupV1BackupsApiAPIService
	serverCategory *ServerCategory
	serverName     *string
	region         *string
	page           *int32
	size           *int32
}

// Backup server category
func (r BackupV1BackupsApiAPIGetBackupTargetListRequest) ServerCategory(serverCategory ServerCategory) BackupV1BackupsApiAPIGetBackupTargetListRequest {
	r.serverCategory = &serverCategory
	return r
}

// Backup server name
func (r BackupV1BackupsApiAPIGetBackupTargetListRequest) ServerName(serverName string) BackupV1BackupsApiAPIGetBackupTargetListRequest {
	r.serverName = &serverName
	return r
}

// Region
func (r BackupV1BackupsApiAPIGetBackupTargetListRequest) Region(region string) BackupV1BackupsApiAPIGetBackupTargetListRequest {
	r.region = &region
	return r
}

// Page
func (r BackupV1BackupsApiAPIGetBackupTargetListRequest) Page(page int32) BackupV1BackupsApiAPIGetBackupTargetListRequest {
	r.page = &page
	return r
}

// Size
func (r BackupV1BackupsApiAPIGetBackupTargetListRequest) Size(size int32) BackupV1BackupsApiAPIGetBackupTargetListRequest {
	r.size = &size
	return r
}

func (r BackupV1BackupsApiAPIGetBackupTargetListRequest) Execute() (*BackupTargetListResponse, *http.Response, error) {
	return r.ApiService.GetBackupTargetListExecute(r)
}

/*
GetBackupTargetList List Backup Targets

List Backup targets.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return BackupV1BackupsApiAPIGetBackupTargetListRequest
*/
func (a *BackupV1BackupsApiAPIService) GetBackupTargetList(ctx context.Context) BackupV1BackupsApiAPIGetBackupTargetListRequest {
	return BackupV1BackupsApiAPIGetBackupTargetListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return BackupTargetListResponse
func (a *BackupV1BackupsApiAPIService) GetBackupTargetListExecute(r BackupV1BackupsApiAPIGetBackupTargetListRequest) (*BackupTargetListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BackupTargetListResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/backups/backup-targets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.serverCategory == nil {
		return localVarReturnValue, nil, reportError("serverCategory is required and must be specified")
	}

	if r.serverName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "server_name", r.serverName, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "server_category", r.serverCategory, "form", "")
	if r.region != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "region", r.region, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "backup 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ValidationErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.ErrorMessage = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.ErrorModel = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BackupV1BackupsApiAPIListBackupRegionRelationshipRequest struct {
	ctx                  context.Context
	ApiService           *BackupV1BackupsApiAPIService
	fromRegion           *string
	fromAvailabilityZone *string
	toRegion             *string
	toAvailabilityZone   *string
}

// Region
func (r BackupV1BackupsApiAPIListBackupRegionRelationshipRequest) FromRegion(fromRegion string) BackupV1BackupsApiAPIListBackupRegionRelationshipRequest {
	r.fromRegion = &fromRegion
	return r
}

// Availability zone name
func (r BackupV1BackupsApiAPIListBackupRegionRelationshipRequest) FromAvailabilityZone(fromAvailabilityZone string) BackupV1BackupsApiAPIListBackupRegionRelationshipRequest {
	r.fromAvailabilityZone = &fromAvailabilityZone
	return r
}

// Region
func (r BackupV1BackupsApiAPIListBackupRegionRelationshipRequest) ToRegion(toRegion string) BackupV1BackupsApiAPIListBackupRegionRelationshipRequest {
	r.toRegion = &toRegion
	return r
}

// Availability zone name
func (r BackupV1BackupsApiAPIListBackupRegionRelationshipRequest) ToAvailabilityZone(toAvailabilityZone string) BackupV1BackupsApiAPIListBackupRegionRelationshipRequest {
	r.toAvailabilityZone = &toAvailabilityZone
	return r
}

func (r BackupV1BackupsApiAPIListBackupRegionRelationshipRequest) Execute() (*BackupListRegionRelationshipResponse, *http.Response, error) {
	return r.ApiService.ListBackupRegionRelationshipExecute(r)
}

/*
ListBackupRegionRelationship List Backup Region Relationship

List Backup Region Relationship.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return BackupV1BackupsApiAPIListBackupRegionRelationshipRequest
*/
func (a *BackupV1BackupsApiAPIService) ListBackupRegionRelationship(ctx context.Context) BackupV1BackupsApiAPIListBackupRegionRelationshipRequest {
	return BackupV1BackupsApiAPIListBackupRegionRelationshipRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return BackupListRegionRelationshipResponse
func (a *BackupV1BackupsApiAPIService) ListBackupRegionRelationshipExecute(r BackupV1BackupsApiAPIListBackupRegionRelationshipRequest) (*BackupListRegionRelationshipResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BackupListRegionRelationshipResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/backups/region-relationship"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fromRegion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_region", r.fromRegion, "form", "")
	}
	if r.fromAvailabilityZone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_availability_zone", r.fromAvailabilityZone, "form", "")
	}
	if r.toRegion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to_region", r.toRegion, "form", "")
	}
	if r.toAvailabilityZone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to_availability_zone", r.toAvailabilityZone, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "backup 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ValidationErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.ErrorMessage = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.ErrorModel = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BackupV1BackupsApiAPIListBackupsRequest struct {
	ctx        context.Context
	ApiService *BackupV1BackupsApiAPIService
	size       *int32
	page       *int32
	sort       *string
	name       *string
	serverName *string
}

// size
func (r BackupV1BackupsApiAPIListBackupsRequest) Size(size int32) BackupV1BackupsApiAPIListBackupsRequest {
	r.size = &size
	return r
}

// page
func (r BackupV1BackupsApiAPIListBackupsRequest) Page(page int32) BackupV1BackupsApiAPIListBackupsRequest {
	r.page = &page
	return r
}

// sort
func (r BackupV1BackupsApiAPIListBackupsRequest) Sort(sort string) BackupV1BackupsApiAPIListBackupsRequest {
	r.sort = &sort
	return r
}

// Backup name
func (r BackupV1BackupsApiAPIListBackupsRequest) Name(name string) BackupV1BackupsApiAPIListBackupsRequest {
	r.name = &name
	return r
}

// Backup server name
func (r BackupV1BackupsApiAPIListBackupsRequest) ServerName(serverName string) BackupV1BackupsApiAPIListBackupsRequest {
	r.serverName = &serverName
	return r
}

func (r BackupV1BackupsApiAPIListBackupsRequest) Execute() (*BackupListResponse, *http.Response, error) {
	return r.ApiService.ListBackupsExecute(r)
}

/*
ListBackups List Backups

List Backups.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return BackupV1BackupsApiAPIListBackupsRequest
*/
func (a *BackupV1BackupsApiAPIService) ListBackups(ctx context.Context) BackupV1BackupsApiAPIListBackupsRequest {
	return BackupV1BackupsApiAPIListBackupsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return BackupListResponse
func (a *BackupV1BackupsApiAPIService) ListBackupsExecute(r BackupV1BackupsApiAPIListBackupsRequest) (*BackupListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BackupListResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/backups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.serverName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "server_name", r.serverName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "backup 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ValidationErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.ErrorMessage = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.ErrorModel = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BackupV1BackupsApiAPIManualBackupRequest struct {
	ctx        context.Context
	ApiService *BackupV1BackupsApiAPIService
	backupId   string
}

func (r BackupV1BackupsApiAPIManualBackupRequest) Execute() (*SyncResponse, *http.Response, error) {
	return r.ApiService.ManualBackupExecute(r)
}

/*
ManualBackup Manual Backup

Perform Manual Backup immediately.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param backupId Backup ID
	@return BackupV1BackupsApiAPIManualBackupRequest
*/
func (a *BackupV1BackupsApiAPIService) ManualBackup(ctx context.Context, backupId string) BackupV1BackupsApiAPIManualBackupRequest {
	return BackupV1BackupsApiAPIManualBackupRequest{
		ApiService: a,
		ctx:        ctx,
		backupId:   backupId,
	}
}

// Execute executes the request
//
//	@return SyncResponse
func (a *BackupV1BackupsApiAPIService) ManualBackupExecute(r BackupV1BackupsApiAPIManualBackupRequest) (*SyncResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SyncResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/backups/{backup_id}/manual-backup"
	localVarPath = strings.Replace(localVarPath, "{"+"backup_id"+"}", url.PathEscape(parameterValueToString(r.backupId, "backupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "backup 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ValidationErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.ErrorMessage = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.ErrorModel = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BackupV1BackupsApiAPIShowBackupRequest struct {
	ctx        context.Context
	ApiService *BackupV1BackupsApiAPIService
	backupId   string
}

func (r BackupV1BackupsApiAPIShowBackupRequest) Execute() (*BackupDetailResponse, *http.Response, error) {
	return r.ApiService.ShowBackupExecute(r)
}

/*
ShowBackup Show Backup

Show the detail of Backup.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param backupId Backup ID
	@return BackupV1BackupsApiAPIShowBackupRequest
*/
func (a *BackupV1BackupsApiAPIService) ShowBackup(ctx context.Context, backupId string) BackupV1BackupsApiAPIShowBackupRequest {
	return BackupV1BackupsApiAPIShowBackupRequest{
		ApiService: a,
		ctx:        ctx,
		backupId:   backupId,
	}
}

// Execute executes the request
//
//	@return BackupDetailResponse
func (a *BackupV1BackupsApiAPIService) ShowBackupExecute(r BackupV1BackupsApiAPIShowBackupRequest) (*BackupDetailResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BackupDetailResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/backups/{backup_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"backup_id"+"}", url.PathEscape(parameterValueToString(r.backupId, "backupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "backup 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ValidationErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.ErrorMessage = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.ErrorModel = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BackupV1BackupsApiAPIUpdateRetentionPeriodRequest struct {
	ctx                       context.Context
	ApiService                *BackupV1BackupsApiAPIService
	backupId                  string
	retentionPeriodUpdateBody *RetentionPeriodUpdateBody
}

func (r BackupV1BackupsApiAPIUpdateRetentionPeriodRequest) RetentionPeriodUpdateBody(retentionPeriodUpdateBody RetentionPeriodUpdateBody) BackupV1BackupsApiAPIUpdateRetentionPeriodRequest {
	r.retentionPeriodUpdateBody = &retentionPeriodUpdateBody
	return r
}

func (r BackupV1BackupsApiAPIUpdateRetentionPeriodRequest) Execute() (*SyncResponse, *http.Response, error) {
	return r.ApiService.UpdateRetentionPeriodExecute(r)
}

/*
UpdateRetentionPeriod Update Retention Period

Update the retention period.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param backupId Backup ID
	@return BackupV1BackupsApiAPIUpdateRetentionPeriodRequest
*/
func (a *BackupV1BackupsApiAPIService) UpdateRetentionPeriod(ctx context.Context, backupId string) BackupV1BackupsApiAPIUpdateRetentionPeriodRequest {
	return BackupV1BackupsApiAPIUpdateRetentionPeriodRequest{
		ApiService: a,
		ctx:        ctx,
		backupId:   backupId,
	}
}

// Execute executes the request
//
//	@return SyncResponse
func (a *BackupV1BackupsApiAPIService) UpdateRetentionPeriodExecute(r BackupV1BackupsApiAPIUpdateRetentionPeriodRequest) (*SyncResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SyncResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/backups/{backup_id}/retention-period"
	localVarPath = strings.Replace(localVarPath, "{"+"backup_id"+"}", url.PathEscape(parameterValueToString(r.backupId, "backupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.retentionPeriodUpdateBody == nil {
		return localVarReturnValue, nil, reportError("retentionPeriodUpdateBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "backup 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.retentionPeriodUpdateBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ValidationErrorModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.ErrorMessage = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.ErrorModel = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
