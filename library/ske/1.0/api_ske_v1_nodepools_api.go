/*
SCP Kubernetes Service

SCP Kubernetes Service

API version: 0.0.1.dev2582
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ske

import (
	"bytes"
	"context"
	scpsdk "github.com/SamsungSDSCloud/terraform-sdk-samsungcloudplatformv2/client"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// SkeV1NodepoolsApiAPIService SkeV1NodepoolsApiAPI service
type SkeV1NodepoolsApiAPIService service

type SkeV1NodepoolsApiAPICreateNodepoolRequest struct {
	ctx                   context.Context
	ApiService            *SkeV1NodepoolsApiAPIService
	nodepoolCreateRequest *NodepoolCreateRequest
}

func (r SkeV1NodepoolsApiAPICreateNodepoolRequest) NodepoolCreateRequest(nodepoolCreateRequest NodepoolCreateRequest) SkeV1NodepoolsApiAPICreateNodepoolRequest {
	r.nodepoolCreateRequest = &nodepoolCreateRequest
	return r
}

func (r SkeV1NodepoolsApiAPICreateNodepoolRequest) Execute() (*NodepoolShowResponse, *http.Response, error) {
	return r.ApiService.CreateNodepoolExecute(r)
}

/*
CreateNodepool Create Nodepool

create a nodepool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SkeV1NodepoolsApiAPICreateNodepoolRequest
*/
func (a *SkeV1NodepoolsApiAPIService) CreateNodepool(ctx context.Context) SkeV1NodepoolsApiAPICreateNodepoolRequest {
	return SkeV1NodepoolsApiAPICreateNodepoolRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return NodepoolShowResponse
func (a *SkeV1NodepoolsApiAPIService) CreateNodepoolExecute(r SkeV1NodepoolsApiAPICreateNodepoolRequest) (*NodepoolShowResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NodepoolShowResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/nodepools"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.nodepoolCreateRequest == nil {
		return localVarReturnValue, nil, reportError("nodepoolCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "ske 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.nodepoolCreateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SkeV1NodepoolsApiAPIDeleteNodepoolRequest struct {
	ctx        context.Context
	ApiService *SkeV1NodepoolsApiAPIService
	nodepoolId string
}

func (r SkeV1NodepoolsApiAPIDeleteNodepoolRequest) Execute() (*AsyncResponse, *http.Response, error) {
	return r.ApiService.DeleteNodepoolExecute(r)
}

/*
DeleteNodepool Delete Nodepool

delete a nodepool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodepoolId Nodepool ID
 @return SkeV1NodepoolsApiAPIDeleteNodepoolRequest
*/
func (a *SkeV1NodepoolsApiAPIService) DeleteNodepool(ctx context.Context, nodepoolId string) SkeV1NodepoolsApiAPIDeleteNodepoolRequest {
	return SkeV1NodepoolsApiAPIDeleteNodepoolRequest{
		ApiService: a,
		ctx:        ctx,
		nodepoolId: nodepoolId,
	}
}

// Execute executes the request
//  @return AsyncResponse
func (a *SkeV1NodepoolsApiAPIService) DeleteNodepoolExecute(r SkeV1NodepoolsApiAPIDeleteNodepoolRequest) (*AsyncResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AsyncResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/nodepools/{nodepool_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"nodepool_id"+"}", url.PathEscape(parameterValueToString(r.nodepoolId, "nodepoolId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "ske 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SkeV1NodepoolsApiAPIListNodepoolNodesRequest struct {
	ctx        context.Context
	ApiService *SkeV1NodepoolsApiAPIService
	nodepoolId string
	size       *int32
	page       *int32
	sort       *string
	nodeName   *string
}

// size
func (r SkeV1NodepoolsApiAPIListNodepoolNodesRequest) Size(size int32) SkeV1NodepoolsApiAPIListNodepoolNodesRequest {
	r.size = &size
	return r
}

// page
func (r SkeV1NodepoolsApiAPIListNodepoolNodesRequest) Page(page int32) SkeV1NodepoolsApiAPIListNodepoolNodesRequest {
	r.page = &page
	return r
}

// sort
func (r SkeV1NodepoolsApiAPIListNodepoolNodesRequest) Sort(sort string) SkeV1NodepoolsApiAPIListNodepoolNodesRequest {
	r.sort = &sort
	return r
}

// Node Name
func (r SkeV1NodepoolsApiAPIListNodepoolNodesRequest) NodeName(nodeName string) SkeV1NodepoolsApiAPIListNodepoolNodesRequest {
	r.nodeName = &nodeName
	return r
}

func (r SkeV1NodepoolsApiAPIListNodepoolNodesRequest) Execute() (*NodeListInNodepoolResponse, *http.Response, error) {
	return r.ApiService.ListNodepoolNodesExecute(r)
}

/*
ListNodepoolNodes List Nodepool Nodes

Get nodepool node list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodepoolId Nodepool ID
 @return SkeV1NodepoolsApiAPIListNodepoolNodesRequest
*/
func (a *SkeV1NodepoolsApiAPIService) ListNodepoolNodes(ctx context.Context, nodepoolId string) SkeV1NodepoolsApiAPIListNodepoolNodesRequest {
	return SkeV1NodepoolsApiAPIListNodepoolNodesRequest{
		ApiService: a,
		ctx:        ctx,
		nodepoolId: nodepoolId,
	}
}

// Execute executes the request
//  @return NodeListInNodepoolResponse
func (a *SkeV1NodepoolsApiAPIService) ListNodepoolNodesExecute(r SkeV1NodepoolsApiAPIListNodepoolNodesRequest) (*NodeListInNodepoolResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NodeListInNodepoolResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/nodepools/{nodepool_id}/nodes"
	localVarPath = strings.Replace(localVarPath, "{"+"nodepool_id"+"}", url.PathEscape(parameterValueToString(r.nodepoolId, "nodepoolId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.nodeName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "node_name", r.nodeName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "ske 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SkeV1NodepoolsApiAPIListNodepoolsRequest struct {
	ctx          context.Context
	ApiService   *SkeV1NodepoolsApiAPIService
	clusterId    string
	size         *int32
	page         *int32
	sort         *string
	nodepoolName *string
}

// size
func (r SkeV1NodepoolsApiAPIListNodepoolsRequest) Size(size int32) SkeV1NodepoolsApiAPIListNodepoolsRequest {
	r.size = &size
	return r
}

// page
func (r SkeV1NodepoolsApiAPIListNodepoolsRequest) Page(page int32) SkeV1NodepoolsApiAPIListNodepoolsRequest {
	r.page = &page
	return r
}

// sort
func (r SkeV1NodepoolsApiAPIListNodepoolsRequest) Sort(sort string) SkeV1NodepoolsApiAPIListNodepoolsRequest {
	r.sort = &sort
	return r
}

// Nodepool Name
func (r SkeV1NodepoolsApiAPIListNodepoolsRequest) NodepoolName(nodepoolName string) SkeV1NodepoolsApiAPIListNodepoolsRequest {
	r.nodepoolName = &nodepoolName
	return r
}

func (r SkeV1NodepoolsApiAPIListNodepoolsRequest) Execute() (*NodepoolListResponse, *http.Response, error) {
	return r.ApiService.ListNodepoolsExecute(r)
}

/*
ListNodepools List Nodepools

get nodepools list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterId Cluster ID
 @return SkeV1NodepoolsApiAPIListNodepoolsRequest
*/
func (a *SkeV1NodepoolsApiAPIService) ListNodepools(ctx context.Context, clusterId string) SkeV1NodepoolsApiAPIListNodepoolsRequest {
	return SkeV1NodepoolsApiAPIListNodepoolsRequest{
		ApiService: a,
		ctx:        ctx,
		clusterId:  clusterId,
	}
}

// Execute executes the request
//  @return NodepoolListResponse
func (a *SkeV1NodepoolsApiAPIService) ListNodepoolsExecute(r SkeV1NodepoolsApiAPIListNodepoolsRequest) (*NodepoolListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NodepoolListResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/clusters/{cluster_id}/nodepools"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", url.PathEscape(parameterValueToString(r.clusterId, "clusterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.nodepoolName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodepool_name", r.nodepoolName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "ske 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SkeV1NodepoolsApiAPISetNodepoolRequest struct {
	ctx                   context.Context
	ApiService            *SkeV1NodepoolsApiAPIService
	nodepoolId            string
	nodepoolUpdateRequest *NodepoolUpdateRequest
}

func (r SkeV1NodepoolsApiAPISetNodepoolRequest) NodepoolUpdateRequest(nodepoolUpdateRequest NodepoolUpdateRequest) SkeV1NodepoolsApiAPISetNodepoolRequest {
	r.nodepoolUpdateRequest = &nodepoolUpdateRequest
	return r
}

func (r SkeV1NodepoolsApiAPISetNodepoolRequest) Execute() (*AsyncResponse, *http.Response, error) {
	return r.ApiService.SetNodepoolExecute(r)
}

/*
SetNodepool Set Nodepool

set a nodepool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodepoolId Nodepool ID
 @return SkeV1NodepoolsApiAPISetNodepoolRequest
*/
func (a *SkeV1NodepoolsApiAPIService) SetNodepool(ctx context.Context, nodepoolId string) SkeV1NodepoolsApiAPISetNodepoolRequest {
	return SkeV1NodepoolsApiAPISetNodepoolRequest{
		ApiService: a,
		ctx:        ctx,
		nodepoolId: nodepoolId,
	}
}

// Execute executes the request
//  @return AsyncResponse
func (a *SkeV1NodepoolsApiAPIService) SetNodepoolExecute(r SkeV1NodepoolsApiAPISetNodepoolRequest) (*AsyncResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AsyncResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/nodepools/{nodepool_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"nodepool_id"+"}", url.PathEscape(parameterValueToString(r.nodepoolId, "nodepoolId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.nodepoolUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("nodepoolUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "ske 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.nodepoolUpdateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SkeV1NodepoolsApiAPISetNodepoolLabelsRequest struct {
	ctx                      context.Context
	ApiService               *SkeV1NodepoolsApiAPIService
	nodepoolId               string
	nodepoolLabelsSetRequest *NodepoolLabelsSetRequest
}

func (r SkeV1NodepoolsApiAPISetNodepoolLabelsRequest) NodepoolLabelsSetRequest(nodepoolLabelsSetRequest NodepoolLabelsSetRequest) SkeV1NodepoolsApiAPISetNodepoolLabelsRequest {
	r.nodepoolLabelsSetRequest = &nodepoolLabelsSetRequest
	return r
}

func (r SkeV1NodepoolsApiAPISetNodepoolLabelsRequest) Execute() (*AsyncResponse, *http.Response, error) {
	return r.ApiService.SetNodepoolLabelsExecute(r)
}

/*
SetNodepoolLabels Set Nodepool Labels

set nodepool labels

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodepoolId Nodepool ID
 @return SkeV1NodepoolsApiAPISetNodepoolLabelsRequest
*/
func (a *SkeV1NodepoolsApiAPIService) SetNodepoolLabels(ctx context.Context, nodepoolId string) SkeV1NodepoolsApiAPISetNodepoolLabelsRequest {
	return SkeV1NodepoolsApiAPISetNodepoolLabelsRequest{
		ApiService: a,
		ctx:        ctx,
		nodepoolId: nodepoolId,
	}
}

// Execute executes the request
//  @return AsyncResponse
func (a *SkeV1NodepoolsApiAPIService) SetNodepoolLabelsExecute(r SkeV1NodepoolsApiAPISetNodepoolLabelsRequest) (*AsyncResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AsyncResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/nodepools/{nodepool_id}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"nodepool_id"+"}", url.PathEscape(parameterValueToString(r.nodepoolId, "nodepoolId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.nodepoolLabelsSetRequest == nil {
		return localVarReturnValue, nil, reportError("nodepoolLabelsSetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "ske 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.nodepoolLabelsSetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SkeV1NodepoolsApiAPISetNodepoolTaintsRequest struct {
	ctx                      context.Context
	ApiService               *SkeV1NodepoolsApiAPIService
	nodepoolId               string
	nodepoolTaintsSetRequest *NodepoolTaintsSetRequest
}

func (r SkeV1NodepoolsApiAPISetNodepoolTaintsRequest) NodepoolTaintsSetRequest(nodepoolTaintsSetRequest NodepoolTaintsSetRequest) SkeV1NodepoolsApiAPISetNodepoolTaintsRequest {
	r.nodepoolTaintsSetRequest = &nodepoolTaintsSetRequest
	return r
}

func (r SkeV1NodepoolsApiAPISetNodepoolTaintsRequest) Execute() (*AsyncResponse, *http.Response, error) {
	return r.ApiService.SetNodepoolTaintsExecute(r)
}

/*
SetNodepoolTaints Set Nodepool Taints

set nodepool taints

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodepoolId Nodepool ID
 @return SkeV1NodepoolsApiAPISetNodepoolTaintsRequest
*/
func (a *SkeV1NodepoolsApiAPIService) SetNodepoolTaints(ctx context.Context, nodepoolId string) SkeV1NodepoolsApiAPISetNodepoolTaintsRequest {
	return SkeV1NodepoolsApiAPISetNodepoolTaintsRequest{
		ApiService: a,
		ctx:        ctx,
		nodepoolId: nodepoolId,
	}
}

// Execute executes the request
//  @return AsyncResponse
func (a *SkeV1NodepoolsApiAPIService) SetNodepoolTaintsExecute(r SkeV1NodepoolsApiAPISetNodepoolTaintsRequest) (*AsyncResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AsyncResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/nodepools/{nodepool_id}/taints"
	localVarPath = strings.Replace(localVarPath, "{"+"nodepool_id"+"}", url.PathEscape(parameterValueToString(r.nodepoolId, "nodepoolId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.nodepoolTaintsSetRequest == nil {
		return localVarReturnValue, nil, reportError("nodepoolTaintsSetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "ske 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.nodepoolTaintsSetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SkeV1NodepoolsApiAPISetNodepoolUpgradeRequest struct {
	ctx        context.Context
	ApiService *SkeV1NodepoolsApiAPIService
	nodepoolId string
}

func (r SkeV1NodepoolsApiAPISetNodepoolUpgradeRequest) Execute() (*AsyncResponse, *http.Response, error) {
	return r.ApiService.SetNodepoolUpgradeExecute(r)
}

/*
SetNodepoolUpgrade Set Nodepool Upgrade

upgrade a nodepool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodepoolId Nodepool ID
 @return SkeV1NodepoolsApiAPISetNodepoolUpgradeRequest
*/
func (a *SkeV1NodepoolsApiAPIService) SetNodepoolUpgrade(ctx context.Context, nodepoolId string) SkeV1NodepoolsApiAPISetNodepoolUpgradeRequest {
	return SkeV1NodepoolsApiAPISetNodepoolUpgradeRequest{
		ApiService: a,
		ctx:        ctx,
		nodepoolId: nodepoolId,
	}
}

// Execute executes the request
//  @return AsyncResponse
func (a *SkeV1NodepoolsApiAPIService) SetNodepoolUpgradeExecute(r SkeV1NodepoolsApiAPISetNodepoolUpgradeRequest) (*AsyncResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AsyncResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/nodepools/{nodepool_id}/upgrade"
	localVarPath = strings.Replace(localVarPath, "{"+"nodepool_id"+"}", url.PathEscape(parameterValueToString(r.nodepoolId, "nodepoolId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "ske 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SkeV1NodepoolsApiAPIShowNodepoolRequest struct {
	ctx        context.Context
	ApiService *SkeV1NodepoolsApiAPIService
	nodepoolId string
}

func (r SkeV1NodepoolsApiAPIShowNodepoolRequest) Execute() (*NodepoolShowResponse, *http.Response, error) {
	return r.ApiService.ShowNodepoolExecute(r)
}

/*
ShowNodepool Show Nodepool

show a nodepool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodepoolId Nodepool ID
 @return SkeV1NodepoolsApiAPIShowNodepoolRequest
*/
func (a *SkeV1NodepoolsApiAPIService) ShowNodepool(ctx context.Context, nodepoolId string) SkeV1NodepoolsApiAPIShowNodepoolRequest {
	return SkeV1NodepoolsApiAPIShowNodepoolRequest{
		ApiService: a,
		ctx:        ctx,
		nodepoolId: nodepoolId,
	}
}

// Execute executes the request
//  @return NodepoolShowResponse
func (a *SkeV1NodepoolsApiAPIService) ShowNodepoolExecute(r SkeV1NodepoolsApiAPIShowNodepoolRequest) (*NodepoolShowResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NodepoolShowResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/nodepools/{nodepool_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"nodepool_id"+"}", url.PathEscape(parameterValueToString(r.nodepoolId, "nodepoolId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "ske 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
