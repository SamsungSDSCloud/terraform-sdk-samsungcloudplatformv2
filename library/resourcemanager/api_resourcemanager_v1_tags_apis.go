/*
SCP Resource manager project

SCP Resource manager project

API version: 0.0.1.dev646
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package resourcemanager

import (
	"bytes"
	"context"
	scpsdk "github.com/SamsungSDSCloud/terraform-sdk-samsungcloudplatformv2/client"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// ResourcemanagerV1TagsAPIsAPIService ResourcemanagerV1TagsAPIsAPI service
type ResourcemanagerV1TagsAPIsAPIService service

type ResourcemanagerV1TagsAPIsAPIDeleteComponentsTagRequest struct {
	ctx                context.Context
	ApiService         *ResourcemanagerV1TagsAPIsAPIService
	region             string
	serviceType        string
	resourceType       string
	resourceIdentifier string
	key                string
}

func (r ResourcemanagerV1TagsAPIsAPIDeleteComponentsTagRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteComponentsTagExecute(r)
}

/*
DeleteComponentsTag DeleteComponentsTag

delete a specific components tag

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param region 리전
	@param serviceType 서비스 유형
	@param resourceType 자원 유형
	@param resourceIdentifier 자원 ID
	@param key 태그 key
	@return ResourcemanagerV1TagsAPIsAPIDeleteComponentsTagRequest
*/
func (a *ResourcemanagerV1TagsAPIsAPIService) DeleteComponentsTag(ctx context.Context, region string, serviceType string, resourceType string, resourceIdentifier string, key string) ResourcemanagerV1TagsAPIsAPIDeleteComponentsTagRequest {
	return ResourcemanagerV1TagsAPIsAPIDeleteComponentsTagRequest{
		ApiService:         a,
		ctx:                ctx,
		region:             region,
		serviceType:        serviceType,
		resourceType:       resourceType,
		resourceIdentifier: resourceIdentifier,
		key:                key,
	}
}

// Execute executes the request
func (a *ResourcemanagerV1TagsAPIsAPIService) DeleteComponentsTagExecute(r ResourcemanagerV1TagsAPIsAPIDeleteComponentsTagRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return nil, err
		}
	}

	localVarPath := basePath + "/v1/tags/{region}/{service_type}/{resource_type}/{resource_identifier}/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(parameterValueToString(r.region, "region")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"service_type"+"}", url.PathEscape(parameterValueToString(r.serviceType, "serviceType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resource_type"+"}", url.PathEscape(parameterValueToString(r.resourceType, "resourceType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resource_identifier"+"}", url.PathEscape(parameterValueToString(r.resourceIdentifier, "resourceIdentifier")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ResourcemanagerV1TagsAPIsAPIDeleteComponentsTagsRequest struct {
	ctx                context.Context
	ApiService         *ResourcemanagerV1TagsAPIsAPIService
	region             string
	serviceType        string
	resourceType       string
	resourceIdentifier string
}

func (r ResourcemanagerV1TagsAPIsAPIDeleteComponentsTagsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteComponentsTagsExecute(r)
}

/*
DeleteComponentsTags DeleteComponentsTags

delete components tags

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param region 리전
	@param serviceType 서비스 유형
	@param resourceType 자원 유형
	@param resourceIdentifier 자원 ID
	@return ResourcemanagerV1TagsAPIsAPIDeleteComponentsTagsRequest
*/
func (a *ResourcemanagerV1TagsAPIsAPIService) DeleteComponentsTags(ctx context.Context, region string, serviceType string, resourceType string, resourceIdentifier string) ResourcemanagerV1TagsAPIsAPIDeleteComponentsTagsRequest {
	return ResourcemanagerV1TagsAPIsAPIDeleteComponentsTagsRequest{
		ApiService:         a,
		ctx:                ctx,
		region:             region,
		serviceType:        serviceType,
		resourceType:       resourceType,
		resourceIdentifier: resourceIdentifier,
	}
}

// Execute executes the request
func (a *ResourcemanagerV1TagsAPIsAPIService) DeleteComponentsTagsExecute(r ResourcemanagerV1TagsAPIsAPIDeleteComponentsTagsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return nil, err
		}
	}

	localVarPath := basePath + "/v1/tags/{region}/{service_type}/{resource_type}/{resource_identifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(parameterValueToString(r.region, "region")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"service_type"+"}", url.PathEscape(parameterValueToString(r.serviceType, "serviceType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resource_type"+"}", url.PathEscape(parameterValueToString(r.resourceType, "resourceType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resource_identifier"+"}", url.PathEscape(parameterValueToString(r.resourceIdentifier, "resourceIdentifier")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ResourcemanagerV1TagsAPIsAPIDeleteResourceTagRequest struct {
	ctx        context.Context
	ApiService *ResourcemanagerV1TagsAPIsAPIService
	srn        string
	key        string
}

func (r ResourcemanagerV1TagsAPIsAPIDeleteResourceTagRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteResourceTagExecute(r)
}

/*
DeleteResourceTag DeleteResourceTag

delete a specific resource tag

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param srn SRN
	@param key 태그 key
	@return ResourcemanagerV1TagsAPIsAPIDeleteResourceTagRequest
*/
func (a *ResourcemanagerV1TagsAPIsAPIService) DeleteResourceTag(ctx context.Context, srn string, key string) ResourcemanagerV1TagsAPIsAPIDeleteResourceTagRequest {
	return ResourcemanagerV1TagsAPIsAPIDeleteResourceTagRequest{
		ApiService: a,
		ctx:        ctx,
		srn:        srn,
		key:        key,
	}
}

// Execute executes the request
func (a *ResourcemanagerV1TagsAPIsAPIService) DeleteResourceTagExecute(r ResourcemanagerV1TagsAPIsAPIDeleteResourceTagRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return nil, err
		}
	}

	localVarPath := basePath + "/v1/tags/{srn}/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"srn"+"}", url.PathEscape(parameterValueToString(r.srn, "srn")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ResourcemanagerV1TagsAPIsAPIDeleteResourceTagsRequest struct {
	ctx        context.Context
	ApiService *ResourcemanagerV1TagsAPIsAPIService
	srn        string
}

func (r ResourcemanagerV1TagsAPIsAPIDeleteResourceTagsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteResourceTagsExecute(r)
}

/*
DeleteResourceTags DeleteResourceTags

delete resource tags

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param srn SRN
	@return ResourcemanagerV1TagsAPIsAPIDeleteResourceTagsRequest
*/
func (a *ResourcemanagerV1TagsAPIsAPIService) DeleteResourceTags(ctx context.Context, srn string) ResourcemanagerV1TagsAPIsAPIDeleteResourceTagsRequest {
	return ResourcemanagerV1TagsAPIsAPIDeleteResourceTagsRequest{
		ApiService: a,
		ctx:        ctx,
		srn:        srn,
	}
}

// Execute executes the request
func (a *ResourcemanagerV1TagsAPIsAPIService) DeleteResourceTagsExecute(r ResourcemanagerV1TagsAPIsAPIDeleteResourceTagsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return nil, err
		}
	}

	localVarPath := basePath + "/v1/tags/{srn}"
	localVarPath = strings.Replace(localVarPath, "{"+"srn"+"}", url.PathEscape(parameterValueToString(r.srn, "srn")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ResourcemanagerV1TagsAPIsAPIDeleteTagsRequest struct {
	ctx              context.Context
	ApiService       *ResourcemanagerV1TagsAPIsAPIService
	tagDeleteRequest *TagDeleteRequest
}

func (r ResourcemanagerV1TagsAPIsAPIDeleteTagsRequest) TagDeleteRequest(tagDeleteRequest TagDeleteRequest) ResourcemanagerV1TagsAPIsAPIDeleteTagsRequest {
	r.tagDeleteRequest = &tagDeleteRequest
	return r
}

func (r ResourcemanagerV1TagsAPIsAPIDeleteTagsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteTagsExecute(r)
}

/*
DeleteTags DeleteTags

delete tags

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ResourcemanagerV1TagsAPIsAPIDeleteTagsRequest
*/
func (a *ResourcemanagerV1TagsAPIsAPIService) DeleteTags(ctx context.Context) ResourcemanagerV1TagsAPIsAPIDeleteTagsRequest {
	return ResourcemanagerV1TagsAPIsAPIDeleteTagsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ResourcemanagerV1TagsAPIsAPIService) DeleteTagsExecute(r ResourcemanagerV1TagsAPIsAPIDeleteTagsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return nil, err
		}
	}

	localVarPath := basePath + "/v1/tags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tagDeleteRequest == nil {
		return nil, reportError("tagDeleteRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tagDeleteRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ResourcemanagerV1TagsAPIsAPIListComponentsTagsRequest struct {
	ctx                context.Context
	ApiService         *ResourcemanagerV1TagsAPIsAPIService
	region             string
	serviceType        string
	resourceType       string
	resourceIdentifier string
	size               *int32
	page               *int32
	sort               *string
}

// size
func (r ResourcemanagerV1TagsAPIsAPIListComponentsTagsRequest) Size(size int32) ResourcemanagerV1TagsAPIsAPIListComponentsTagsRequest {
	r.size = &size
	return r
}

// page
func (r ResourcemanagerV1TagsAPIsAPIListComponentsTagsRequest) Page(page int32) ResourcemanagerV1TagsAPIsAPIListComponentsTagsRequest {
	r.page = &page
	return r
}

// sort
func (r ResourcemanagerV1TagsAPIsAPIListComponentsTagsRequest) Sort(sort string) ResourcemanagerV1TagsAPIsAPIListComponentsTagsRequest {
	r.sort = &sort
	return r
}

func (r ResourcemanagerV1TagsAPIsAPIListComponentsTagsRequest) Execute() (*TagShowListResponse, *http.Response, error) {
	return r.ApiService.ListComponentsTagsExecute(r)
}

/*
ListComponentsTags ListComponentsTags

get components tags

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param region 리전
	@param serviceType 서비스 유형
	@param resourceType 자원 유형
	@param resourceIdentifier 자원 ID
	@return ResourcemanagerV1TagsAPIsAPIListComponentsTagsRequest
*/
func (a *ResourcemanagerV1TagsAPIsAPIService) ListComponentsTags(ctx context.Context, region string, serviceType string, resourceType string, resourceIdentifier string) ResourcemanagerV1TagsAPIsAPIListComponentsTagsRequest {
	return ResourcemanagerV1TagsAPIsAPIListComponentsTagsRequest{
		ApiService:         a,
		ctx:                ctx,
		region:             region,
		serviceType:        serviceType,
		resourceType:       resourceType,
		resourceIdentifier: resourceIdentifier,
	}
}

// Execute executes the request
//
//	@return TagShowListResponse
func (a *ResourcemanagerV1TagsAPIsAPIService) ListComponentsTagsExecute(r ResourcemanagerV1TagsAPIsAPIListComponentsTagsRequest) (*TagShowListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TagShowListResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/tags/{region}/{service_type}/{resource_type}/{resource_identifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(parameterValueToString(r.region, "region")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"service_type"+"}", url.PathEscape(parameterValueToString(r.serviceType, "serviceType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resource_type"+"}", url.PathEscape(parameterValueToString(r.resourceType, "resourceType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resource_identifier"+"}", url.PathEscape(parameterValueToString(r.resourceIdentifier, "resourceIdentifier")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourcemanagerV1TagsAPIsAPIListResourceTagsRequest struct {
	ctx        context.Context
	ApiService *ResourcemanagerV1TagsAPIsAPIService
	srn        string
	size       *int32
	page       *int32
	sort       *string
}

// size
func (r ResourcemanagerV1TagsAPIsAPIListResourceTagsRequest) Size(size int32) ResourcemanagerV1TagsAPIsAPIListResourceTagsRequest {
	r.size = &size
	return r
}

// page
func (r ResourcemanagerV1TagsAPIsAPIListResourceTagsRequest) Page(page int32) ResourcemanagerV1TagsAPIsAPIListResourceTagsRequest {
	r.page = &page
	return r
}

// sort
func (r ResourcemanagerV1TagsAPIsAPIListResourceTagsRequest) Sort(sort string) ResourcemanagerV1TagsAPIsAPIListResourceTagsRequest {
	r.sort = &sort
	return r
}

func (r ResourcemanagerV1TagsAPIsAPIListResourceTagsRequest) Execute() (*TagShowListResponse, *http.Response, error) {
	return r.ApiService.ListResourceTagsExecute(r)
}

/*
ListResourceTags ListResourceTags

get resource tags

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param srn SRN
	@return ResourcemanagerV1TagsAPIsAPIListResourceTagsRequest
*/
func (a *ResourcemanagerV1TagsAPIsAPIService) ListResourceTags(ctx context.Context, srn string) ResourcemanagerV1TagsAPIsAPIListResourceTagsRequest {
	return ResourcemanagerV1TagsAPIsAPIListResourceTagsRequest{
		ApiService: a,
		ctx:        ctx,
		srn:        srn,
	}
}

// Execute executes the request
//
//	@return TagShowListResponse
func (a *ResourcemanagerV1TagsAPIsAPIService) ListResourceTagsExecute(r ResourcemanagerV1TagsAPIsAPIListResourceTagsRequest) (*TagShowListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TagShowListResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/tags/{srn}"
	localVarPath = strings.Replace(localVarPath, "{"+"srn"+"}", url.PathEscape(parameterValueToString(r.srn, "srn")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourcemanagerV1TagsAPIsAPIListTagKeysRequest struct {
	ctx        context.Context
	ApiService *ResourcemanagerV1TagsAPIsAPIService
	key        *string
}

// 태그 key
func (r ResourcemanagerV1TagsAPIsAPIListTagKeysRequest) Key(key string) ResourcemanagerV1TagsAPIsAPIListTagKeysRequest {
	r.key = &key
	return r
}

func (r ResourcemanagerV1TagsAPIsAPIListTagKeysRequest) Execute() (*TagKeyResponse, *http.Response, error) {
	return r.ApiService.ListTagKeysExecute(r)
}

/*
ListTagKeys ListTagKeys

get tag key list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ResourcemanagerV1TagsAPIsAPIListTagKeysRequest
*/
func (a *ResourcemanagerV1TagsAPIsAPIService) ListTagKeys(ctx context.Context) ResourcemanagerV1TagsAPIsAPIListTagKeysRequest {
	return ResourcemanagerV1TagsAPIsAPIListTagKeysRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return TagKeyResponse
func (a *ResourcemanagerV1TagsAPIsAPIService) ListTagKeysExecute(r ResourcemanagerV1TagsAPIsAPIListTagKeysRequest) (*TagKeyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TagKeyResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/tags/keys"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourcemanagerV1TagsAPIsAPIListTagValuesRequest struct {
	ctx        context.Context
	ApiService *ResourcemanagerV1TagsAPIsAPIService
	key        *string
	value      *string
}

// 태그 key
func (r ResourcemanagerV1TagsAPIsAPIListTagValuesRequest) Key(key string) ResourcemanagerV1TagsAPIsAPIListTagValuesRequest {
	r.key = &key
	return r
}

// 태그 value
func (r ResourcemanagerV1TagsAPIsAPIListTagValuesRequest) Value(value string) ResourcemanagerV1TagsAPIsAPIListTagValuesRequest {
	r.value = &value
	return r
}

func (r ResourcemanagerV1TagsAPIsAPIListTagValuesRequest) Execute() (*TagValueResponse, *http.Response, error) {
	return r.ApiService.ListTagValuesExecute(r)
}

/*
ListTagValues ListTagValues

get tag value list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ResourcemanagerV1TagsAPIsAPIListTagValuesRequest
*/
func (a *ResourcemanagerV1TagsAPIsAPIService) ListTagValues(ctx context.Context) ResourcemanagerV1TagsAPIsAPIListTagValuesRequest {
	return ResourcemanagerV1TagsAPIsAPIListTagValuesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return TagValueResponse
func (a *ResourcemanagerV1TagsAPIsAPIService) ListTagValuesExecute(r ResourcemanagerV1TagsAPIsAPIListTagValuesRequest) (*TagValueResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TagValueResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/tags/values"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "form", "")
	}
	if r.value != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "value", r.value, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourcemanagerV1TagsAPIsAPIListTagsRequest struct {
	ctx                context.Context
	ApiService         *ResourcemanagerV1TagsAPIsAPIService
	size               *int32
	page               *int32
	sort               *string
	accountId          *string
	key                *string
	value              *string
	resourceIdentifier *string
	resourceType       *string
	serviceType        *string
	offering           *string
	region             *string
}

// size
func (r ResourcemanagerV1TagsAPIsAPIListTagsRequest) Size(size int32) ResourcemanagerV1TagsAPIsAPIListTagsRequest {
	r.size = &size
	return r
}

// page
func (r ResourcemanagerV1TagsAPIsAPIListTagsRequest) Page(page int32) ResourcemanagerV1TagsAPIsAPIListTagsRequest {
	r.page = &page
	return r
}

// sort
func (r ResourcemanagerV1TagsAPIsAPIListTagsRequest) Sort(sort string) ResourcemanagerV1TagsAPIsAPIListTagsRequest {
	r.sort = &sort
	return r
}

// 어카운트 ID
func (r ResourcemanagerV1TagsAPIsAPIListTagsRequest) AccountId(accountId string) ResourcemanagerV1TagsAPIsAPIListTagsRequest {
	r.accountId = &accountId
	return r
}

// 태그 key
func (r ResourcemanagerV1TagsAPIsAPIListTagsRequest) Key(key string) ResourcemanagerV1TagsAPIsAPIListTagsRequest {
	r.key = &key
	return r
}

// 태그 value
func (r ResourcemanagerV1TagsAPIsAPIListTagsRequest) Value(value string) ResourcemanagerV1TagsAPIsAPIListTagsRequest {
	r.value = &value
	return r
}

// 자원 ID
func (r ResourcemanagerV1TagsAPIsAPIListTagsRequest) ResourceIdentifier(resourceIdentifier string) ResourcemanagerV1TagsAPIsAPIListTagsRequest {
	r.resourceIdentifier = &resourceIdentifier
	return r
}

// 자원 유형
func (r ResourcemanagerV1TagsAPIsAPIListTagsRequest) ResourceType(resourceType string) ResourcemanagerV1TagsAPIsAPIListTagsRequest {
	r.resourceType = &resourceType
	return r
}

// 서비스 유형
func (r ResourcemanagerV1TagsAPIsAPIListTagsRequest) ServiceType(serviceType string) ResourcemanagerV1TagsAPIsAPIListTagsRequest {
	r.serviceType = &serviceType
	return r
}

// SCP 운영 단위
func (r ResourcemanagerV1TagsAPIsAPIListTagsRequest) Offering(offering string) ResourcemanagerV1TagsAPIsAPIListTagsRequest {
	r.offering = &offering
	return r
}

// 리전
func (r ResourcemanagerV1TagsAPIsAPIListTagsRequest) Region(region string) ResourcemanagerV1TagsAPIsAPIListTagsRequest {
	r.region = &region
	return r
}

func (r ResourcemanagerV1TagsAPIsAPIListTagsRequest) Execute() (*TagListResponse, *http.Response, error) {
	return r.ApiService.ListTagsExecute(r)
}

/*
ListTags ListTags

get tag list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ResourcemanagerV1TagsAPIsAPIListTagsRequest
*/
func (a *ResourcemanagerV1TagsAPIsAPIService) ListTags(ctx context.Context) ResourcemanagerV1TagsAPIsAPIListTagsRequest {
	return ResourcemanagerV1TagsAPIsAPIListTagsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return TagListResponse
func (a *ResourcemanagerV1TagsAPIsAPIService) ListTagsExecute(r ResourcemanagerV1TagsAPIsAPIListTagsRequest) (*TagListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TagListResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/tags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account_id", r.accountId, "form", "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "form", "")
	}
	if r.value != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "value", r.value, "form", "")
	}
	if r.resourceIdentifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource_identifier", r.resourceIdentifier, "form", "")
	}
	if r.resourceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource_type", r.resourceType, "form", "")
	}
	if r.serviceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "service_type", r.serviceType, "form", "")
	}
	if r.offering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offering", r.offering, "form", "")
	}
	if r.region != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "region", r.region, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourcemanagerV1TagsAPIsAPIShowComponentsTagRequest struct {
	ctx                context.Context
	ApiService         *ResourcemanagerV1TagsAPIsAPIService
	region             string
	serviceType        string
	resourceType       string
	resourceIdentifier string
	key                string
}

func (r ResourcemanagerV1TagsAPIsAPIShowComponentsTagRequest) Execute() (*TagShowResponse, *http.Response, error) {
	return r.ApiService.ShowComponentsTagExecute(r)
}

/*
ShowComponentsTag ShowComponentsTag

get a specific components tag

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param region 리전
	@param serviceType 서비스 유형
	@param resourceType 자원 유형
	@param resourceIdentifier 자원 ID
	@param key 태그 key
	@return ResourcemanagerV1TagsAPIsAPIShowComponentsTagRequest
*/
func (a *ResourcemanagerV1TagsAPIsAPIService) ShowComponentsTag(ctx context.Context, region string, serviceType string, resourceType string, resourceIdentifier string, key string) ResourcemanagerV1TagsAPIsAPIShowComponentsTagRequest {
	return ResourcemanagerV1TagsAPIsAPIShowComponentsTagRequest{
		ApiService:         a,
		ctx:                ctx,
		region:             region,
		serviceType:        serviceType,
		resourceType:       resourceType,
		resourceIdentifier: resourceIdentifier,
		key:                key,
	}
}

// Execute executes the request
//
//	@return TagShowResponse
func (a *ResourcemanagerV1TagsAPIsAPIService) ShowComponentsTagExecute(r ResourcemanagerV1TagsAPIsAPIShowComponentsTagRequest) (*TagShowResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TagShowResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/tags/{region}/{service_type}/{resource_type}/{resource_identifier}/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(parameterValueToString(r.region, "region")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"service_type"+"}", url.PathEscape(parameterValueToString(r.serviceType, "serviceType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resource_type"+"}", url.PathEscape(parameterValueToString(r.resourceType, "resourceType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resource_identifier"+"}", url.PathEscape(parameterValueToString(r.resourceIdentifier, "resourceIdentifier")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourcemanagerV1TagsAPIsAPIShowResourceTagRequest struct {
	ctx        context.Context
	ApiService *ResourcemanagerV1TagsAPIsAPIService
	srn        string
	key        string
}

func (r ResourcemanagerV1TagsAPIsAPIShowResourceTagRequest) Execute() (*TagShowResponse, *http.Response, error) {
	return r.ApiService.ShowResourceTagExecute(r)
}

/*
ShowResourceTag ShowResourceTag

get a specific resource tag

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param srn SRN
	@param key 태그 key
	@return ResourcemanagerV1TagsAPIsAPIShowResourceTagRequest
*/
func (a *ResourcemanagerV1TagsAPIsAPIService) ShowResourceTag(ctx context.Context, srn string, key string) ResourcemanagerV1TagsAPIsAPIShowResourceTagRequest {
	return ResourcemanagerV1TagsAPIsAPIShowResourceTagRequest{
		ApiService: a,
		ctx:        ctx,
		srn:        srn,
		key:        key,
	}
}

// Execute executes the request
//
//	@return TagShowResponse
func (a *ResourcemanagerV1TagsAPIsAPIService) ShowResourceTagExecute(r ResourcemanagerV1TagsAPIsAPIShowResourceTagRequest) (*TagShowResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TagShowResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/tags/{srn}/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"srn"+"}", url.PathEscape(parameterValueToString(r.srn, "srn")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourcemanagerV1TagsAPIsAPIUpdateComponentsTagValueRequest struct {
	ctx                context.Context
	ApiService         *ResourcemanagerV1TagsAPIsAPIService
	region             string
	serviceType        string
	resourceType       string
	resourceIdentifier string
	key                string
	tagValue           *TagValue
}

func (r ResourcemanagerV1TagsAPIsAPIUpdateComponentsTagValueRequest) TagValue(tagValue TagValue) ResourcemanagerV1TagsAPIsAPIUpdateComponentsTagValueRequest {
	r.tagValue = &tagValue
	return r
}

func (r ResourcemanagerV1TagsAPIsAPIUpdateComponentsTagValueRequest) Execute() (*TagBaseResponse, *http.Response, error) {
	return r.ApiService.UpdateComponentsTagValueExecute(r)
}

/*
UpdateComponentsTagValue UpdateComponentsTagValue

update components tag value

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param region 리전
	@param serviceType 서비스 유형
	@param resourceType 자원 유형
	@param resourceIdentifier 자원 ID
	@param key 태그 key
	@return ResourcemanagerV1TagsAPIsAPIUpdateComponentsTagValueRequest
*/
func (a *ResourcemanagerV1TagsAPIsAPIService) UpdateComponentsTagValue(ctx context.Context, region string, serviceType string, resourceType string, resourceIdentifier string, key string) ResourcemanagerV1TagsAPIsAPIUpdateComponentsTagValueRequest {
	return ResourcemanagerV1TagsAPIsAPIUpdateComponentsTagValueRequest{
		ApiService:         a,
		ctx:                ctx,
		region:             region,
		serviceType:        serviceType,
		resourceType:       resourceType,
		resourceIdentifier: resourceIdentifier,
		key:                key,
	}
}

// Execute executes the request
//
//	@return TagBaseResponse
func (a *ResourcemanagerV1TagsAPIsAPIService) UpdateComponentsTagValueExecute(r ResourcemanagerV1TagsAPIsAPIUpdateComponentsTagValueRequest) (*TagBaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TagBaseResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/tags/{region}/{service_type}/{resource_type}/{resource_identifier}/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(parameterValueToString(r.region, "region")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"service_type"+"}", url.PathEscape(parameterValueToString(r.serviceType, "serviceType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resource_type"+"}", url.PathEscape(parameterValueToString(r.resourceType, "resourceType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resource_identifier"+"}", url.PathEscape(parameterValueToString(r.resourceIdentifier, "resourceIdentifier")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tagValue == nil {
		return localVarReturnValue, nil, reportError("tagValue is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tagValue
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourcemanagerV1TagsAPIsAPIUpdateComponentsTagsRequest struct {
	ctx                context.Context
	ApiService         *ResourcemanagerV1TagsAPIsAPIService
	region             string
	serviceType        string
	resourceType       string
	resourceIdentifier string
	tagSetRequest      *TagSetRequest
}

func (r ResourcemanagerV1TagsAPIsAPIUpdateComponentsTagsRequest) TagSetRequest(tagSetRequest TagSetRequest) ResourcemanagerV1TagsAPIsAPIUpdateComponentsTagsRequest {
	r.tagSetRequest = &tagSetRequest
	return r
}

func (r ResourcemanagerV1TagsAPIsAPIUpdateComponentsTagsRequest) Execute() (*TagBaseResponse, *http.Response, error) {
	return r.ApiService.UpdateComponentsTagsExecute(r)
}

/*
UpdateComponentsTags UpdateComponentsTags

update components tags

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param region 리전
	@param serviceType 서비스 유형
	@param resourceType 자원 유형
	@param resourceIdentifier 자원 ID
	@return ResourcemanagerV1TagsAPIsAPIUpdateComponentsTagsRequest
*/
func (a *ResourcemanagerV1TagsAPIsAPIService) UpdateComponentsTags(ctx context.Context, region string, serviceType string, resourceType string, resourceIdentifier string) ResourcemanagerV1TagsAPIsAPIUpdateComponentsTagsRequest {
	return ResourcemanagerV1TagsAPIsAPIUpdateComponentsTagsRequest{
		ApiService:         a,
		ctx:                ctx,
		region:             region,
		serviceType:        serviceType,
		resourceType:       resourceType,
		resourceIdentifier: resourceIdentifier,
	}
}

// Execute executes the request
//
//	@return TagBaseResponse
func (a *ResourcemanagerV1TagsAPIsAPIService) UpdateComponentsTagsExecute(r ResourcemanagerV1TagsAPIsAPIUpdateComponentsTagsRequest) (*TagBaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TagBaseResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/tags/{region}/{service_type}/{resource_type}/{resource_identifier}/bulk"
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(parameterValueToString(r.region, "region")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"service_type"+"}", url.PathEscape(parameterValueToString(r.serviceType, "serviceType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resource_type"+"}", url.PathEscape(parameterValueToString(r.resourceType, "resourceType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resource_identifier"+"}", url.PathEscape(parameterValueToString(r.resourceIdentifier, "resourceIdentifier")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tagSetRequest == nil {
		return localVarReturnValue, nil, reportError("tagSetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tagSetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourcemanagerV1TagsAPIsAPIUpdateResourceTagValueRequest struct {
	ctx        context.Context
	ApiService *ResourcemanagerV1TagsAPIsAPIService
	srn        string
	key        string
	tagValue   *TagValue
}

func (r ResourcemanagerV1TagsAPIsAPIUpdateResourceTagValueRequest) TagValue(tagValue TagValue) ResourcemanagerV1TagsAPIsAPIUpdateResourceTagValueRequest {
	r.tagValue = &tagValue
	return r
}

func (r ResourcemanagerV1TagsAPIsAPIUpdateResourceTagValueRequest) Execute() (*TagBaseResponse, *http.Response, error) {
	return r.ApiService.UpdateResourceTagValueExecute(r)
}

/*
UpdateResourceTagValue UpdateResourceTagValue

update resource tag value

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param srn SRN
	@param key 태그 key
	@return ResourcemanagerV1TagsAPIsAPIUpdateResourceTagValueRequest
*/
func (a *ResourcemanagerV1TagsAPIsAPIService) UpdateResourceTagValue(ctx context.Context, srn string, key string) ResourcemanagerV1TagsAPIsAPIUpdateResourceTagValueRequest {
	return ResourcemanagerV1TagsAPIsAPIUpdateResourceTagValueRequest{
		ApiService: a,
		ctx:        ctx,
		srn:        srn,
		key:        key,
	}
}

// Execute executes the request
//
//	@return TagBaseResponse
func (a *ResourcemanagerV1TagsAPIsAPIService) UpdateResourceTagValueExecute(r ResourcemanagerV1TagsAPIsAPIUpdateResourceTagValueRequest) (*TagBaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TagBaseResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/tags/{srn}/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"srn"+"}", url.PathEscape(parameterValueToString(r.srn, "srn")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tagValue == nil {
		return localVarReturnValue, nil, reportError("tagValue is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tagValue
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourcemanagerV1TagsAPIsAPIUpdateResourceTagsRequest struct {
	ctx           context.Context
	ApiService    *ResourcemanagerV1TagsAPIsAPIService
	srn           string
	tagSetRequest *TagSetRequest
}

func (r ResourcemanagerV1TagsAPIsAPIUpdateResourceTagsRequest) TagSetRequest(tagSetRequest TagSetRequest) ResourcemanagerV1TagsAPIsAPIUpdateResourceTagsRequest {
	r.tagSetRequest = &tagSetRequest
	return r
}

func (r ResourcemanagerV1TagsAPIsAPIUpdateResourceTagsRequest) Execute() (*TagBaseResponse, *http.Response, error) {
	return r.ApiService.UpdateResourceTagsExecute(r)
}

/*
UpdateResourceTags UpdateResourceTags

update resource tags

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param srn SRN
	@return ResourcemanagerV1TagsAPIsAPIUpdateResourceTagsRequest
*/
func (a *ResourcemanagerV1TagsAPIsAPIService) UpdateResourceTags(ctx context.Context, srn string) ResourcemanagerV1TagsAPIsAPIUpdateResourceTagsRequest {
	return ResourcemanagerV1TagsAPIsAPIUpdateResourceTagsRequest{
		ApiService: a,
		ctx:        ctx,
		srn:        srn,
	}
}

// Execute executes the request
//
//	@return TagBaseResponse
func (a *ResourcemanagerV1TagsAPIsAPIService) UpdateResourceTagsExecute(r ResourcemanagerV1TagsAPIsAPIUpdateResourceTagsRequest) (*TagBaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TagBaseResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/tags/{srn}/bulk"
	localVarPath = strings.Replace(localVarPath, "{"+"srn"+"}", url.PathEscape(parameterValueToString(r.srn, "srn")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tagSetRequest == nil {
		return localVarReturnValue, nil, reportError("tagSetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tagSetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourcemanagerV1TagsAPIsAPIUpdateTagsRequest struct {
	ctx            context.Context
	ApiService     *ResourcemanagerV1TagsAPIsAPIService
	tagsSetRequest *TagsSetRequest
}

func (r ResourcemanagerV1TagsAPIsAPIUpdateTagsRequest) TagsSetRequest(tagsSetRequest TagsSetRequest) ResourcemanagerV1TagsAPIsAPIUpdateTagsRequest {
	r.tagsSetRequest = &tagsSetRequest
	return r
}

func (r ResourcemanagerV1TagsAPIsAPIUpdateTagsRequest) Execute() (*TagBaseResponse, *http.Response, error) {
	return r.ApiService.UpdateTagsExecute(r)
}

/*
UpdateTags UpdateTags

update tags

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ResourcemanagerV1TagsAPIsAPIUpdateTagsRequest
*/
func (a *ResourcemanagerV1TagsAPIsAPIService) UpdateTags(ctx context.Context) ResourcemanagerV1TagsAPIsAPIUpdateTagsRequest {
	return ResourcemanagerV1TagsAPIsAPIUpdateTagsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return TagBaseResponse
func (a *ResourcemanagerV1TagsAPIsAPIService) UpdateTagsExecute(r ResourcemanagerV1TagsAPIsAPIUpdateTagsRequest) (*TagBaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TagBaseResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/tags/bulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tagsSetRequest == nil {
		return localVarReturnValue, nil, reportError("tagsSetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tagsSetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
