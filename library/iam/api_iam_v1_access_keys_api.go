/*
SCP IAM Service

SCP IAM Service

API version: 0.0.1.dev1432
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package iam

import (
	"bytes"
	"context"
	scpsdk "github.com/SamsungSDSCloud/terraform-sdk-samsungcloudplatformv2/client"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// IamV1AccessKeysApiAPIService IamV1AccessKeysApiAPI service
type IamV1AccessKeysApiAPIService service

type IamV1AccessKeysApiAPIAccessKeyCreateRequest struct {
	ctx                    context.Context
	ApiService             *IamV1AccessKeysApiAPIService
	accessKeyCreateRequest *AccessKeyCreateRequest
}

func (r IamV1AccessKeysApiAPIAccessKeyCreateRequest) AccessKeyCreateRequest(accessKeyCreateRequest AccessKeyCreateRequest) IamV1AccessKeysApiAPIAccessKeyCreateRequest {
	r.accessKeyCreateRequest = &accessKeyCreateRequest
	return r
}

func (r IamV1AccessKeysApiAPIAccessKeyCreateRequest) Execute() (*AccessKeyResponse, *http.Response, error) {
	return r.ApiService.AccessKeyCreateExecute(r)
}

/*
AccessKeyCreate Create an access key

Create an access key

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return IamV1AccessKeysApiAPIAccessKeyCreateRequest
*/
func (a *IamV1AccessKeysApiAPIService) AccessKeyCreate(ctx context.Context) IamV1AccessKeysApiAPIAccessKeyCreateRequest {
	return IamV1AccessKeysApiAPIAccessKeyCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AccessKeyResponse
func (a *IamV1AccessKeysApiAPIService) AccessKeyCreateExecute(r IamV1AccessKeysApiAPIAccessKeyCreateRequest) (*AccessKeyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AccessKeyResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/access-keys"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accessKeyCreateRequest == nil {
		return localVarReturnValue, nil, reportError("accessKeyCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.accessKeyCreateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type IamV1AccessKeysApiAPIAccessKeyDeleteRequest struct {
	ctx         context.Context
	ApiService  *IamV1AccessKeysApiAPIService
	accessKeyId string
}

func (r IamV1AccessKeysApiAPIAccessKeyDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AccessKeyDeleteExecute(r)
}

/*
AccessKeyDelete Remove the access key

Remove the access key

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accessKeyId Access key ID
	@return IamV1AccessKeysApiAPIAccessKeyDeleteRequest
*/
func (a *IamV1AccessKeysApiAPIService) AccessKeyDelete(ctx context.Context, accessKeyId string) IamV1AccessKeysApiAPIAccessKeyDeleteRequest {
	return IamV1AccessKeysApiAPIAccessKeyDeleteRequest{
		ApiService:  a,
		ctx:         ctx,
		accessKeyId: accessKeyId,
	}
}

// Execute executes the request
func (a *IamV1AccessKeysApiAPIService) AccessKeyDeleteExecute(r IamV1AccessKeysApiAPIAccessKeyDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return nil, err
		}
	}

	localVarPath := basePath + "/v1/access-keys/{access_key_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"access_key_id"+"}", url.PathEscape(parameterValueToString(r.accessKeyId, "accessKeyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type IamV1AccessKeysApiAPIAccessKeyListRequest struct {
	ctx               context.Context
	ApiService        *IamV1AccessKeysApiAPIService
	withCount         *string
	limit             *int32
	marker            *string
	sort              *string
	accountId         *string
	accessKeyType     *string
	parentAccessKeyId *string
}

// with count
func (r IamV1AccessKeysApiAPIAccessKeyListRequest) WithCount(withCount string) IamV1AccessKeysApiAPIAccessKeyListRequest {
	r.withCount = &withCount
	return r
}

// limit
func (r IamV1AccessKeysApiAPIAccessKeyListRequest) Limit(limit int32) IamV1AccessKeysApiAPIAccessKeyListRequest {
	r.limit = &limit
	return r
}

// marker
func (r IamV1AccessKeysApiAPIAccessKeyListRequest) Marker(marker string) IamV1AccessKeysApiAPIAccessKeyListRequest {
	r.marker = &marker
	return r
}

// sort
func (r IamV1AccessKeysApiAPIAccessKeyListRequest) Sort(sort string) IamV1AccessKeysApiAPIAccessKeyListRequest {
	r.sort = &sort
	return r
}

// Project ID
func (r IamV1AccessKeysApiAPIAccessKeyListRequest) AccountId(accountId string) IamV1AccessKeysApiAPIAccessKeyListRequest {
	r.accountId = &accountId
	return r
}

// Access key type
func (r IamV1AccessKeysApiAPIAccessKeyListRequest) AccessKeyType(accessKeyType string) IamV1AccessKeysApiAPIAccessKeyListRequest {
	r.accessKeyType = &accessKeyType
	return r
}

// Parent access key ID
func (r IamV1AccessKeysApiAPIAccessKeyListRequest) ParentAccessKeyId(parentAccessKeyId string) IamV1AccessKeysApiAPIAccessKeyListRequest {
	r.parentAccessKeyId = &parentAccessKeyId
	return r
}

func (r IamV1AccessKeysApiAPIAccessKeyListRequest) Execute() (*ListAccessKeyResponse, *http.Response, error) {
	return r.ApiService.AccessKeyListExecute(r)
}

/*
AccessKeyList List access keys

List access keys

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return IamV1AccessKeysApiAPIAccessKeyListRequest
*/
func (a *IamV1AccessKeysApiAPIService) AccessKeyList(ctx context.Context) IamV1AccessKeysApiAPIAccessKeyListRequest {
	return IamV1AccessKeysApiAPIAccessKeyListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ListAccessKeyResponse
func (a *IamV1AccessKeysApiAPIService) AccessKeyListExecute(r IamV1AccessKeysApiAPIAccessKeyListRequest) (*ListAccessKeyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListAccessKeyResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/access-keys"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.withCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_count", r.withCount, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.marker != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marker", r.marker, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account_id", r.accountId, "form", "")
	}
	if r.accessKeyType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "access_key_type", r.accessKeyType, "form", "")
	}
	if r.parentAccessKeyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_access_key_id", r.parentAccessKeyId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type IamV1AccessKeysApiAPIAccessKeyRefreshRequest struct {
	ctx                     context.Context
	ApiService              *IamV1AccessKeysApiAPIService
	refreshAccessKeyRequest *RefreshAccessKeyRequest
}

func (r IamV1AccessKeysApiAPIAccessKeyRefreshRequest) RefreshAccessKeyRequest(refreshAccessKeyRequest RefreshAccessKeyRequest) IamV1AccessKeysApiAPIAccessKeyRefreshRequest {
	r.refreshAccessKeyRequest = &refreshAccessKeyRequest
	return r
}

func (r IamV1AccessKeysApiAPIAccessKeyRefreshRequest) Execute() (*AccessKeyResponse, *http.Response, error) {
	return r.ApiService.AccessKeyRefreshExecute(r)
}

/*
AccessKeyRefresh Refresh access key token

Refresh access key token

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return IamV1AccessKeysApiAPIAccessKeyRefreshRequest
*/
func (a *IamV1AccessKeysApiAPIService) AccessKeyRefresh(ctx context.Context) IamV1AccessKeysApiAPIAccessKeyRefreshRequest {
	return IamV1AccessKeysApiAPIAccessKeyRefreshRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AccessKeyResponse
func (a *IamV1AccessKeysApiAPIService) AccessKeyRefreshExecute(r IamV1AccessKeysApiAPIAccessKeyRefreshRequest) (*AccessKeyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AccessKeyResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/access-keys/refresh"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.refreshAccessKeyRequest == nil {
		return localVarReturnValue, nil, reportError("refreshAccessKeyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.refreshAccessKeyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type IamV1AccessKeysApiAPIAccessKeySendTemporaryOtpRequest struct {
	ctx                 context.Context
	ApiService          *IamV1AccessKeysApiAPIService
	accessKeyOtpRequest *AccessKeyOtpRequest
}

func (r IamV1AccessKeysApiAPIAccessKeySendTemporaryOtpRequest) AccessKeyOtpRequest(accessKeyOtpRequest AccessKeyOtpRequest) IamV1AccessKeysApiAPIAccessKeySendTemporaryOtpRequest {
	r.accessKeyOtpRequest = &accessKeyOtpRequest
	return r
}

func (r IamV1AccessKeysApiAPIAccessKeySendTemporaryOtpRequest) Execute() (*http.Response, error) {
	return r.ApiService.AccessKeySendTemporaryOtpExecute(r)
}

/*
AccessKeySendTemporaryOtp Send Temporary Access Key OTP

Send Temporary Access Key OTP

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return IamV1AccessKeysApiAPIAccessKeySendTemporaryOtpRequest
*/
func (a *IamV1AccessKeysApiAPIService) AccessKeySendTemporaryOtp(ctx context.Context) IamV1AccessKeysApiAPIAccessKeySendTemporaryOtpRequest {
	return IamV1AccessKeysApiAPIAccessKeySendTemporaryOtpRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *IamV1AccessKeysApiAPIService) AccessKeySendTemporaryOtpExecute(r IamV1AccessKeysApiAPIAccessKeySendTemporaryOtpRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return nil, err
		}
	}

	localVarPath := basePath + "/v1/access-keys/send-otp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accessKeyOtpRequest == nil {
		return nil, reportError("accessKeyOtpRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.accessKeyOtpRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type IamV1AccessKeysApiAPIAccessKeyShowRequest struct {
	ctx         context.Context
	ApiService  *IamV1AccessKeysApiAPIService
	accessKeyId string
}

func (r IamV1AccessKeysApiAPIAccessKeyShowRequest) Execute() (*AccessKeyResponse, *http.Response, error) {
	return r.ApiService.AccessKeyShowExecute(r)
}

/*
AccessKeyShow Get an access key

Get an access key

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accessKeyId Access key ID
	@return IamV1AccessKeysApiAPIAccessKeyShowRequest
*/
func (a *IamV1AccessKeysApiAPIService) AccessKeyShow(ctx context.Context, accessKeyId string) IamV1AccessKeysApiAPIAccessKeyShowRequest {
	return IamV1AccessKeysApiAPIAccessKeyShowRequest{
		ApiService:  a,
		ctx:         ctx,
		accessKeyId: accessKeyId,
	}
}

// Execute executes the request
//
//	@return AccessKeyResponse
func (a *IamV1AccessKeysApiAPIService) AccessKeyShowExecute(r IamV1AccessKeysApiAPIAccessKeyShowRequest) (*AccessKeyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AccessKeyResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/access-keys/{access_key_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"access_key_id"+"}", url.PathEscape(parameterValueToString(r.accessKeyId, "accessKeyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
