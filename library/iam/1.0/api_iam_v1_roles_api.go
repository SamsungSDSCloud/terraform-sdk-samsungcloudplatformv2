/*
SCP IAM Service

SCP IAM Service

API version: 0.0.1.dev2450
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package iam

import (
	"bytes"
	"context"
	scpsdk "github.com/SamsungSDSCloud/terraform-sdk-samsungcloudplatformv2/client"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// IamV1RolesApiAPIService IamV1RolesApiAPI service
type IamV1RolesApiAPIService service

type IamV1RolesApiAPIAddRolePolicyBindingsRequest struct {
	ctx                      context.Context
	ApiService               *IamV1RolesApiAPIService
	roleId                   string
	rolePolicyBindingRequest *RolePolicyBindingRequest
}

func (r IamV1RolesApiAPIAddRolePolicyBindingsRequest) RolePolicyBindingRequest(rolePolicyBindingRequest RolePolicyBindingRequest) IamV1RolesApiAPIAddRolePolicyBindingsRequest {
	r.rolePolicyBindingRequest = &rolePolicyBindingRequest
	return r
}

func (r IamV1RolesApiAPIAddRolePolicyBindingsRequest) Execute() (*RolePolicyBindingResponse, *http.Response, error) {
	return r.ApiService.AddRolePolicyBindingsExecute(r)
}

/*
AddRolePolicyBindings Attach policies to Role

Attach policies to Role

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param roleId 역할 ID
	@return IamV1RolesApiAPIAddRolePolicyBindingsRequest
*/
func (a *IamV1RolesApiAPIService) AddRolePolicyBindings(ctx context.Context, roleId string) IamV1RolesApiAPIAddRolePolicyBindingsRequest {
	return IamV1RolesApiAPIAddRolePolicyBindingsRequest{
		ApiService: a,
		ctx:        ctx,
		roleId:     roleId,
	}
}

// Execute executes the request
//
//	@return RolePolicyBindingResponse
func (a *IamV1RolesApiAPIService) AddRolePolicyBindingsExecute(r IamV1RolesApiAPIAddRolePolicyBindingsRequest) (*RolePolicyBindingResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RolePolicyBindingResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/roles/{role_id}/policy-bindings"
	localVarPath = strings.Replace(localVarPath, "{"+"role_id"+"}", url.PathEscape(parameterValueToString(r.roleId, "roleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rolePolicyBindingRequest == nil {
		return localVarReturnValue, nil, reportError("rolePolicyBindingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "iam 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rolePolicyBindingRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type IamV1RolesApiAPICreateRoleRequest struct {
	ctx               context.Context
	ApiService        *IamV1RolesApiAPIService
	roleCreateRequest *RoleCreateRequest
}

func (r IamV1RolesApiAPICreateRoleRequest) RoleCreateRequest(roleCreateRequest RoleCreateRequest) IamV1RolesApiAPICreateRoleRequest {
	r.roleCreateRequest = &roleCreateRequest
	return r
}

func (r IamV1RolesApiAPICreateRoleRequest) Execute() (*RoleShowResponse, *http.Response, error) {
	return r.ApiService.CreateRoleExecute(r)
}

/*
CreateRole Create role

Create role

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return IamV1RolesApiAPICreateRoleRequest
*/
func (a *IamV1RolesApiAPIService) CreateRole(ctx context.Context) IamV1RolesApiAPICreateRoleRequest {
	return IamV1RolesApiAPICreateRoleRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return RoleShowResponse
func (a *IamV1RolesApiAPIService) CreateRoleExecute(r IamV1RolesApiAPICreateRoleRequest) (*RoleShowResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RoleShowResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/roles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.roleCreateRequest == nil {
		return localVarReturnValue, nil, reportError("roleCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "iam 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleCreateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type IamV1RolesApiAPIDeleteBulkRoleRequest struct {
	ctx                   context.Context
	ApiService            *IamV1RolesApiAPIService
	roleBulkDeleteRequest *RoleBulkDeleteRequest
}

func (r IamV1RolesApiAPIDeleteBulkRoleRequest) RoleBulkDeleteRequest(roleBulkDeleteRequest RoleBulkDeleteRequest) IamV1RolesApiAPIDeleteBulkRoleRequest {
	r.roleBulkDeleteRequest = &roleBulkDeleteRequest
	return r
}

func (r IamV1RolesApiAPIDeleteBulkRoleRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteBulkRoleExecute(r)
}

/*
DeleteBulkRole Delete bulk role

Delete bulk role

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return IamV1RolesApiAPIDeleteBulkRoleRequest
*/
func (a *IamV1RolesApiAPIService) DeleteBulkRole(ctx context.Context) IamV1RolesApiAPIDeleteBulkRoleRequest {
	return IamV1RolesApiAPIDeleteBulkRoleRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *IamV1RolesApiAPIService) DeleteBulkRoleExecute(r IamV1RolesApiAPIDeleteBulkRoleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return nil, err
		}
	}

	localVarPath := basePath + "/v1/roles/bulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.roleBulkDeleteRequest == nil {
		return nil, reportError("roleBulkDeleteRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	localVarHeaderParams["Scp-API-Version"] = "iam 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleBulkDeleteRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type IamV1RolesApiAPIDeleteRoleRequest struct {
	ctx        context.Context
	ApiService *IamV1RolesApiAPIService
	roleId     string
}

func (r IamV1RolesApiAPIDeleteRoleRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRoleExecute(r)
}

/*
DeleteRole Delete role

Delete role

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param roleId 역할 ID
	@return IamV1RolesApiAPIDeleteRoleRequest
*/
func (a *IamV1RolesApiAPIService) DeleteRole(ctx context.Context, roleId string) IamV1RolesApiAPIDeleteRoleRequest {
	return IamV1RolesApiAPIDeleteRoleRequest{
		ApiService: a,
		ctx:        ctx,
		roleId:     roleId,
	}
}

// Execute executes the request
func (a *IamV1RolesApiAPIService) DeleteRoleExecute(r IamV1RolesApiAPIDeleteRoleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return nil, err
		}
	}

	localVarPath := basePath + "/v1/roles/{role_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"role_id"+"}", url.PathEscape(parameterValueToString(r.roleId, "roleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	localVarHeaderParams["Scp-API-Version"] = "iam 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type IamV1RolesApiAPIListRoleRequest struct {
	ctx             context.Context
	ApiService      *IamV1RolesApiAPIService
	size            *int32
	page            *int32
	sort            *string
	name            *string
	types           *string
	accountId       *string
	excludePolicyId *string
}

// size
func (r IamV1RolesApiAPIListRoleRequest) Size(size int32) IamV1RolesApiAPIListRoleRequest {
	r.size = &size
	return r
}

// page
func (r IamV1RolesApiAPIListRoleRequest) Page(page int32) IamV1RolesApiAPIListRoleRequest {
	r.page = &page
	return r
}

// sort
func (r IamV1RolesApiAPIListRoleRequest) Sort(sort string) IamV1RolesApiAPIListRoleRequest {
	r.sort = &sort
	return r
}

// 역할명
func (r IamV1RolesApiAPIListRoleRequest) Name(name string) IamV1RolesApiAPIListRoleRequest {
	r.name = &name
	return r
}

// 역할 유형
func (r IamV1RolesApiAPIListRoleRequest) Types(types string) IamV1RolesApiAPIListRoleRequest {
	r.types = &types
	return r
}

// 역할이 속한 계정의 ID
func (r IamV1RolesApiAPIListRoleRequest) AccountId(accountId string) IamV1RolesApiAPIListRoleRequest {
	r.accountId = &accountId
	return r
}

// 예외 대상 정책
func (r IamV1RolesApiAPIListRoleRequest) ExcludePolicyId(excludePolicyId string) IamV1RolesApiAPIListRoleRequest {
	r.excludePolicyId = &excludePolicyId
	return r
}

func (r IamV1RolesApiAPIListRoleRequest) Execute() (*RolePageResponse, *http.Response, error) {
	return r.ApiService.ListRoleExecute(r)
}

/*
ListRole Get role list

Get role list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return IamV1RolesApiAPIListRoleRequest
*/
func (a *IamV1RolesApiAPIService) ListRole(ctx context.Context) IamV1RolesApiAPIListRoleRequest {
	return IamV1RolesApiAPIListRoleRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return RolePageResponse
func (a *IamV1RolesApiAPIService) ListRoleExecute(r IamV1RolesApiAPIListRoleRequest) (*RolePageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RolePageResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/roles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.types != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "types", r.types, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account_id", r.accountId, "form", "")
	}
	if r.excludePolicyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_policy_id", r.excludePolicyId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "iam 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type IamV1RolesApiAPIListRolePolicyBindingsRequest struct {
	ctx        context.Context
	ApiService *IamV1RolesApiAPIService
	roleId     string
	size       *int32
	page       *int32
	sort       *string
	policyName *string
}

// size
func (r IamV1RolesApiAPIListRolePolicyBindingsRequest) Size(size int32) IamV1RolesApiAPIListRolePolicyBindingsRequest {
	r.size = &size
	return r
}

// page
func (r IamV1RolesApiAPIListRolePolicyBindingsRequest) Page(page int32) IamV1RolesApiAPIListRolePolicyBindingsRequest {
	r.page = &page
	return r
}

// sort
func (r IamV1RolesApiAPIListRolePolicyBindingsRequest) Sort(sort string) IamV1RolesApiAPIListRolePolicyBindingsRequest {
	r.sort = &sort
	return r
}

// 역할에 연결된 정책 이름
func (r IamV1RolesApiAPIListRolePolicyBindingsRequest) PolicyName(policyName string) IamV1RolesApiAPIListRolePolicyBindingsRequest {
	r.policyName = &policyName
	return r
}

func (r IamV1RolesApiAPIListRolePolicyBindingsRequest) Execute() (*RolePolicyBindingResponse, *http.Response, error) {
	return r.ApiService.ListRolePolicyBindingsExecute(r)
}

/*
ListRolePolicyBindings Get Role Policy-Binding list

Get Role Policy-Binding list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param roleId 역할 ID
	@return IamV1RolesApiAPIListRolePolicyBindingsRequest
*/
func (a *IamV1RolesApiAPIService) ListRolePolicyBindings(ctx context.Context, roleId string) IamV1RolesApiAPIListRolePolicyBindingsRequest {
	return IamV1RolesApiAPIListRolePolicyBindingsRequest{
		ApiService: a,
		ctx:        ctx,
		roleId:     roleId,
	}
}

// Execute executes the request
//
//	@return RolePolicyBindingResponse
func (a *IamV1RolesApiAPIService) ListRolePolicyBindingsExecute(r IamV1RolesApiAPIListRolePolicyBindingsRequest) (*RolePolicyBindingResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RolePolicyBindingResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/roles/{role_id}/policy-bindings"
	localVarPath = strings.Replace(localVarPath, "{"+"role_id"+"}", url.PathEscape(parameterValueToString(r.roleId, "roleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.policyName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "policy_name", r.policyName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "iam 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type IamV1RolesApiAPIRemoveBulkRolePolicyBindingsRequest struct {
	ctx        context.Context
	ApiService *IamV1RolesApiAPIService
	roleId     string
}

func (r IamV1RolesApiAPIRemoveBulkRolePolicyBindingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveBulkRolePolicyBindingsExecute(r)
}

/*
RemoveBulkRolePolicyBindings Detach policies to Role

Detach policies to Role

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param roleId 역할 ID
	@return IamV1RolesApiAPIRemoveBulkRolePolicyBindingsRequest
*/
func (a *IamV1RolesApiAPIService) RemoveBulkRolePolicyBindings(ctx context.Context, roleId string) IamV1RolesApiAPIRemoveBulkRolePolicyBindingsRequest {
	return IamV1RolesApiAPIRemoveBulkRolePolicyBindingsRequest{
		ApiService: a,
		ctx:        ctx,
		roleId:     roleId,
	}
}

// Execute executes the request
func (a *IamV1RolesApiAPIService) RemoveBulkRolePolicyBindingsExecute(r IamV1RolesApiAPIRemoveBulkRolePolicyBindingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return nil, err
		}
	}

	localVarPath := basePath + "/v1/roles/{role_id}/policy-bindings"
	localVarPath = strings.Replace(localVarPath, "{"+"role_id"+"}", url.PathEscape(parameterValueToString(r.roleId, "roleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	localVarHeaderParams["Scp-API-Version"] = "iam 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type IamV1RolesApiAPIRemoveRolePolicyBindingRequest struct {
	ctx        context.Context
	ApiService *IamV1RolesApiAPIService
	roleId     string
	policyId   string
}

func (r IamV1RolesApiAPIRemoveRolePolicyBindingRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveRolePolicyBindingExecute(r)
}

/*
RemoveRolePolicyBinding Detach policy to Role

Detach policy to Role

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param roleId 역할 ID
	@param policyId 역할에 연결된 정책 ID
	@return IamV1RolesApiAPIRemoveRolePolicyBindingRequest
*/
func (a *IamV1RolesApiAPIService) RemoveRolePolicyBinding(ctx context.Context, roleId string, policyId string) IamV1RolesApiAPIRemoveRolePolicyBindingRequest {
	return IamV1RolesApiAPIRemoveRolePolicyBindingRequest{
		ApiService: a,
		ctx:        ctx,
		roleId:     roleId,
		policyId:   policyId,
	}
}

// Execute executes the request
func (a *IamV1RolesApiAPIService) RemoveRolePolicyBindingExecute(r IamV1RolesApiAPIRemoveRolePolicyBindingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return nil, err
		}
	}

	localVarPath := basePath + "/v1/roles/{role_id}/policy-bindings/{policy_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"role_id"+"}", url.PathEscape(parameterValueToString(r.roleId, "roleId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policy_id"+"}", url.PathEscape(parameterValueToString(r.policyId, "policyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	localVarHeaderParams["Scp-API-Version"] = "iam 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type IamV1RolesApiAPISetRoleRequest struct {
	ctx            context.Context
	ApiService     *IamV1RolesApiAPIService
	roleId         string
	roleSetRequest *RoleSetRequest
}

func (r IamV1RolesApiAPISetRoleRequest) RoleSetRequest(roleSetRequest RoleSetRequest) IamV1RolesApiAPISetRoleRequest {
	r.roleSetRequest = &roleSetRequest
	return r
}

func (r IamV1RolesApiAPISetRoleRequest) Execute() (*RoleShowResponse, *http.Response, error) {
	return r.ApiService.SetRoleExecute(r)
}

/*
SetRole Set role

Set role

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param roleId 역할 ID
	@return IamV1RolesApiAPISetRoleRequest
*/
func (a *IamV1RolesApiAPIService) SetRole(ctx context.Context, roleId string) IamV1RolesApiAPISetRoleRequest {
	return IamV1RolesApiAPISetRoleRequest{
		ApiService: a,
		ctx:        ctx,
		roleId:     roleId,
	}
}

// Execute executes the request
//
//	@return RoleShowResponse
func (a *IamV1RolesApiAPIService) SetRoleExecute(r IamV1RolesApiAPISetRoleRequest) (*RoleShowResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RoleShowResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/roles/{role_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"role_id"+"}", url.PathEscape(parameterValueToString(r.roleId, "roleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.roleSetRequest == nil {
		return localVarReturnValue, nil, reportError("roleSetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "iam 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleSetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type IamV1RolesApiAPISetRoleTrustPolicyRequest struct {
	ctx                    context.Context
	ApiService             *IamV1RolesApiAPIService
	roleId                 string
	roleTrustPolicyRequest *RoleTrustPolicyRequest
}

func (r IamV1RolesApiAPISetRoleTrustPolicyRequest) RoleTrustPolicyRequest(roleTrustPolicyRequest RoleTrustPolicyRequest) IamV1RolesApiAPISetRoleTrustPolicyRequest {
	r.roleTrustPolicyRequest = &roleTrustPolicyRequest
	return r
}

func (r IamV1RolesApiAPISetRoleTrustPolicyRequest) Execute() (*RoleShowResponse, *http.Response, error) {
	return r.ApiService.SetRoleTrustPolicyExecute(r)
}

/*
SetRoleTrustPolicy Set role trust policy

Set role trust policy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param roleId 역할 ID
	@return IamV1RolesApiAPISetRoleTrustPolicyRequest
*/
func (a *IamV1RolesApiAPIService) SetRoleTrustPolicy(ctx context.Context, roleId string) IamV1RolesApiAPISetRoleTrustPolicyRequest {
	return IamV1RolesApiAPISetRoleTrustPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		roleId:     roleId,
	}
}

// Execute executes the request
//
//	@return RoleShowResponse
func (a *IamV1RolesApiAPIService) SetRoleTrustPolicyExecute(r IamV1RolesApiAPISetRoleTrustPolicyRequest) (*RoleShowResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RoleShowResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/roles/{role_id}/trust-policy"
	localVarPath = strings.Replace(localVarPath, "{"+"role_id"+"}", url.PathEscape(parameterValueToString(r.roleId, "roleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.roleTrustPolicyRequest == nil {
		return localVarReturnValue, nil, reportError("roleTrustPolicyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "iam 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleTrustPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type IamV1RolesApiAPIShowRoleRequest struct {
	ctx        context.Context
	ApiService *IamV1RolesApiAPIService
	roleId     string
}

func (r IamV1RolesApiAPIShowRoleRequest) Execute() (*RoleShowResponse, *http.Response, error) {
	return r.ApiService.ShowRoleExecute(r)
}

/*
ShowRole Get role

Get role

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param roleId 역할 ID
	@return IamV1RolesApiAPIShowRoleRequest
*/
func (a *IamV1RolesApiAPIService) ShowRole(ctx context.Context, roleId string) IamV1RolesApiAPIShowRoleRequest {
	return IamV1RolesApiAPIShowRoleRequest{
		ApiService: a,
		ctx:        ctx,
		roleId:     roleId,
	}
}

// Execute executes the request
//
//	@return RoleShowResponse
func (a *IamV1RolesApiAPIService) ShowRoleExecute(r IamV1RolesApiAPIShowRoleRequest) (*RoleShowResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RoleShowResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/roles/{role_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"role_id"+"}", url.PathEscape(parameterValueToString(r.roleId, "roleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "iam 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
