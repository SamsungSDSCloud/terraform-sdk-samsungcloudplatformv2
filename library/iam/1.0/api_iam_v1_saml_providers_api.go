/*
SCP IAM Service

SCP IAM Service

API version: 0.0.1.dev2450
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package iam

import (
	"bytes"
	"context"
	scpsdk "github.com/SamsungSDSCloud/terraform-sdk-samsungcloudplatformv2/client"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
)

// IamV1SamlProvidersApiAPIService IamV1SamlProvidersApiAPI service
type IamV1SamlProvidersApiAPIService service

type IamV1SamlProvidersApiAPICreateSamlProviderRequest struct {
	ctx              context.Context
	ApiService       *IamV1SamlProvidersApiAPIService
	accountId        *string
	federationType   *string
	samlProviderName *string
	description      *string
	file             *os.File
	tags             *[]map[string]string
}

// Account ID
func (r IamV1SamlProvidersApiAPICreateSamlProviderRequest) AccountId(accountId string) IamV1SamlProvidersApiAPICreateSamlProviderRequest {
	r.accountId = &accountId
	return r
}

// 자격증명공급자 유형
func (r IamV1SamlProvidersApiAPICreateSamlProviderRequest) FederationType(federationType string) IamV1SamlProvidersApiAPICreateSamlProviderRequest {
	r.federationType = &federationType
	return r
}

// 자격증명공급자 이름
func (r IamV1SamlProvidersApiAPICreateSamlProviderRequest) SamlProviderName(samlProviderName string) IamV1SamlProvidersApiAPICreateSamlProviderRequest {
	r.samlProviderName = &samlProviderName
	return r
}

func (r IamV1SamlProvidersApiAPICreateSamlProviderRequest) Description(description string) IamV1SamlProvidersApiAPICreateSamlProviderRequest {
	r.description = &description
	return r
}

// 메타데이터 파일
func (r IamV1SamlProvidersApiAPICreateSamlProviderRequest) File(file *os.File) IamV1SamlProvidersApiAPICreateSamlProviderRequest {
	r.file = file
	return r
}

func (r IamV1SamlProvidersApiAPICreateSamlProviderRequest) Tags(tags []map[string]string) IamV1SamlProvidersApiAPICreateSamlProviderRequest {
	r.tags = &tags
	return r
}

func (r IamV1SamlProvidersApiAPICreateSamlProviderRequest) Execute() (*SamlProviderCreateResponse, *http.Response, error) {
	return r.ApiService.CreateSamlProviderExecute(r)
}

/*
CreateSamlProvider Create a saml provider

Create a saml provider

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return IamV1SamlProvidersApiAPICreateSamlProviderRequest
*/
func (a *IamV1SamlProvidersApiAPIService) CreateSamlProvider(ctx context.Context) IamV1SamlProvidersApiAPICreateSamlProviderRequest {
	return IamV1SamlProvidersApiAPICreateSamlProviderRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SamlProviderCreateResponse
func (a *IamV1SamlProvidersApiAPIService) CreateSamlProviderExecute(r IamV1SamlProvidersApiAPICreateSamlProviderRequest) (*SamlProviderCreateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SamlProviderCreateResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/saml-providers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.federationType == nil {
		return localVarReturnValue, nil, reportError("federationType is required and must be specified")
	}
	if r.samlProviderName == nil {
		return localVarReturnValue, nil, reportError("samlProviderName is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "iam 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "account_id", r.accountId, "", "")
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "description", r.description, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "federation_type", r.federationType, "", "")
	var fileLocalVarFormFileName string
	var fileLocalVarFileName string
	var fileLocalVarFileBytes []byte

	fileLocalVarFormFileName = "file"
	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "saml_provider_name", r.samlProviderName, "", "")
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "tags", r.tags, "", "csv")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type IamV1SamlProvidersApiAPIDeleteSamlProvidersRequest struct {
	ctx                           context.Context
	ApiService                    *IamV1SamlProvidersApiAPIService
	listSamlProviderRemoveRequest *ListSamlProviderRemoveRequest
}

func (r IamV1SamlProvidersApiAPIDeleteSamlProvidersRequest) ListSamlProviderRemoveRequest(listSamlProviderRemoveRequest ListSamlProviderRemoveRequest) IamV1SamlProvidersApiAPIDeleteSamlProvidersRequest {
	r.listSamlProviderRemoveRequest = &listSamlProviderRemoveRequest
	return r
}

func (r IamV1SamlProvidersApiAPIDeleteSamlProvidersRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSamlProvidersExecute(r)
}

/*
DeleteSamlProviders Remove saml providers

Remove saml providers

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return IamV1SamlProvidersApiAPIDeleteSamlProvidersRequest
*/
func (a *IamV1SamlProvidersApiAPIService) DeleteSamlProviders(ctx context.Context) IamV1SamlProvidersApiAPIDeleteSamlProvidersRequest {
	return IamV1SamlProvidersApiAPIDeleteSamlProvidersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *IamV1SamlProvidersApiAPIService) DeleteSamlProvidersExecute(r IamV1SamlProvidersApiAPIDeleteSamlProvidersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return nil, err
		}
	}

	localVarPath := basePath + "/v1/saml-providers/bulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.listSamlProviderRemoveRequest == nil {
		return nil, reportError("listSamlProviderRemoveRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	localVarHeaderParams["Scp-API-Version"] = "iam 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.listSamlProviderRemoveRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type IamV1SamlProvidersApiAPIListSamlProviderRequest struct {
	ctx              context.Context
	ApiService       *IamV1SamlProvidersApiAPIService
	size             *int32
	page             *int32
	sort             *string
	federationType   *string
	samlProviderName *string
}

// size
func (r IamV1SamlProvidersApiAPIListSamlProviderRequest) Size(size int32) IamV1SamlProvidersApiAPIListSamlProviderRequest {
	r.size = &size
	return r
}

// page
func (r IamV1SamlProvidersApiAPIListSamlProviderRequest) Page(page int32) IamV1SamlProvidersApiAPIListSamlProviderRequest {
	r.page = &page
	return r
}

// sort
func (r IamV1SamlProvidersApiAPIListSamlProviderRequest) Sort(sort string) IamV1SamlProvidersApiAPIListSamlProviderRequest {
	r.sort = &sort
	return r
}

// 자격증명공급자 유형
func (r IamV1SamlProvidersApiAPIListSamlProviderRequest) FederationType(federationType string) IamV1SamlProvidersApiAPIListSamlProviderRequest {
	r.federationType = &federationType
	return r
}

// 자격증명공급자 이름
func (r IamV1SamlProvidersApiAPIListSamlProviderRequest) SamlProviderName(samlProviderName string) IamV1SamlProvidersApiAPIListSamlProviderRequest {
	r.samlProviderName = &samlProviderName
	return r
}

func (r IamV1SamlProvidersApiAPIListSamlProviderRequest) Execute() (*ListSamlProviderResponse, *http.Response, error) {
	return r.ApiService.ListSamlProviderExecute(r)
}

/*
ListSamlProvider List saml providers

List saml providers

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return IamV1SamlProvidersApiAPIListSamlProviderRequest
*/
func (a *IamV1SamlProvidersApiAPIService) ListSamlProvider(ctx context.Context) IamV1SamlProvidersApiAPIListSamlProviderRequest {
	return IamV1SamlProvidersApiAPIListSamlProviderRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ListSamlProviderResponse
func (a *IamV1SamlProvidersApiAPIService) ListSamlProviderExecute(r IamV1SamlProvidersApiAPIListSamlProviderRequest) (*ListSamlProviderResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListSamlProviderResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/saml-providers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.federationType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "federation_type", r.federationType, "form", "")
	}
	if r.samlProviderName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "saml_provider_name", r.samlProviderName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "iam 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type IamV1SamlProvidersApiAPISetSamlProviderRequest struct {
	ctx              context.Context
	ApiService       *IamV1SamlProvidersApiAPIService
	samlProviderId   string
	description      *string
	file             *os.File
	samlProviderName *string
	tags             *[]map[string]string
}

func (r IamV1SamlProvidersApiAPISetSamlProviderRequest) Description(description string) IamV1SamlProvidersApiAPISetSamlProviderRequest {
	r.description = &description
	return r
}

// 메타데이터 파일
func (r IamV1SamlProvidersApiAPISetSamlProviderRequest) File(file *os.File) IamV1SamlProvidersApiAPISetSamlProviderRequest {
	r.file = file
	return r
}

func (r IamV1SamlProvidersApiAPISetSamlProviderRequest) SamlProviderName(samlProviderName string) IamV1SamlProvidersApiAPISetSamlProviderRequest {
	r.samlProviderName = &samlProviderName
	return r
}

func (r IamV1SamlProvidersApiAPISetSamlProviderRequest) Tags(tags []map[string]string) IamV1SamlProvidersApiAPISetSamlProviderRequest {
	r.tags = &tags
	return r
}

func (r IamV1SamlProvidersApiAPISetSamlProviderRequest) Execute() (*SamlProviderDetailResponse, *http.Response, error) {
	return r.ApiService.SetSamlProviderExecute(r)
}

/*
SetSamlProvider Update saml provider information

Update saml provider information

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param samlProviderId 자격증명공급자 ID
	@return IamV1SamlProvidersApiAPISetSamlProviderRequest
*/
func (a *IamV1SamlProvidersApiAPIService) SetSamlProvider(ctx context.Context, samlProviderId string) IamV1SamlProvidersApiAPISetSamlProviderRequest {
	return IamV1SamlProvidersApiAPISetSamlProviderRequest{
		ApiService:     a,
		ctx:            ctx,
		samlProviderId: samlProviderId,
	}
}

// Execute executes the request
//
//	@return SamlProviderDetailResponse
func (a *IamV1SamlProvidersApiAPIService) SetSamlProviderExecute(r IamV1SamlProvidersApiAPISetSamlProviderRequest) (*SamlProviderDetailResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SamlProviderDetailResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/saml-providers/{saml_provider_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"saml_provider_id"+"}", url.PathEscape(parameterValueToString(r.samlProviderId, "samlProviderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "iam 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "description", r.description, "", "")
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName string
	var fileLocalVarFileBytes []byte

	fileLocalVarFormFileName = "file"
	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	if r.samlProviderName != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "saml_provider_name", r.samlProviderName, "", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "tags", r.tags, "", "csv")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type IamV1SamlProvidersApiAPIShowSamlProviderRequest struct {
	ctx            context.Context
	ApiService     *IamV1SamlProvidersApiAPIService
	samlProviderId string
}

func (r IamV1SamlProvidersApiAPIShowSamlProviderRequest) Execute() (*SamlProviderDetailResponse, *http.Response, error) {
	return r.ApiService.ShowSamlProviderExecute(r)
}

/*
ShowSamlProvider Get saml provider information

Get saml provider information

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param samlProviderId 자격증명공급자 ID
	@return IamV1SamlProvidersApiAPIShowSamlProviderRequest
*/
func (a *IamV1SamlProvidersApiAPIService) ShowSamlProvider(ctx context.Context, samlProviderId string) IamV1SamlProvidersApiAPIShowSamlProviderRequest {
	return IamV1SamlProvidersApiAPIShowSamlProviderRequest{
		ApiService:     a,
		ctx:            ctx,
		samlProviderId: samlProviderId,
	}
}

// Execute executes the request
//
//	@return SamlProviderDetailResponse
func (a *IamV1SamlProvidersApiAPIService) ShowSamlProviderExecute(r IamV1SamlProvidersApiAPIShowSamlProviderRequest) (*SamlProviderDetailResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SamlProviderDetailResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/saml-providers/{saml_provider_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"saml_provider_id"+"}", url.PathEscape(parameterValueToString(r.samlProviderId, "samlProviderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	localVarHeaderParams["Scp-API-Version"] = "iam 1.0"

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
