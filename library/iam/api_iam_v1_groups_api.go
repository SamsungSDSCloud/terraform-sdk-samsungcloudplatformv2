/*
SCP IAM Service

SCP IAM Service

API version: 0.0.1.dev1432
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package iam

import (
	"bytes"
	"context"
	scpsdk "github.com/SamsungSDSCloud/terraform-sdk-samsungcloudplatformv2/client"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// IamV1GroupsApiAPIService IamV1GroupsApiAPI service
type IamV1GroupsApiAPIService service

type IamV1GroupsApiAPIAddGroupMemberRequest struct {
	ctx                      context.Context
	ApiService               *IamV1GroupsApiAPIService
	groupId                  string
	groupMemberCreateRequest *GroupMemberCreateRequest
}

func (r IamV1GroupsApiAPIAddGroupMemberRequest) GroupMemberCreateRequest(groupMemberCreateRequest GroupMemberCreateRequest) IamV1GroupsApiAPIAddGroupMemberRequest {
	r.groupMemberCreateRequest = &groupMemberCreateRequest
	return r
}

func (r IamV1GroupsApiAPIAddGroupMemberRequest) Execute() (*GroupMemberShowResponse, *http.Response, error) {
	return r.ApiService.AddGroupMemberExecute(r)
}

/*
AddGroupMember Add a user to a group

Add a user to a group

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Group ID
	@return IamV1GroupsApiAPIAddGroupMemberRequest
*/
func (a *IamV1GroupsApiAPIService) AddGroupMember(ctx context.Context, groupId string) IamV1GroupsApiAPIAddGroupMemberRequest {
	return IamV1GroupsApiAPIAddGroupMemberRequest{
		ApiService: a,
		ctx:        ctx,
		groupId:    groupId,
	}
}

// Execute executes the request
//
//	@return GroupMemberShowResponse
func (a *IamV1GroupsApiAPIService) AddGroupMemberExecute(r IamV1GroupsApiAPIAddGroupMemberRequest) (*GroupMemberShowResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GroupMemberShowResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/groups/{group_id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"group_id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupMemberCreateRequest == nil {
		return localVarReturnValue, nil, reportError("groupMemberCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupMemberCreateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type IamV1GroupsApiAPIAddGroupPolicyBindingRequest struct {
	ctx                       context.Context
	ApiService                *IamV1GroupsApiAPIService
	groupId                   string
	groupPolicyBindingRequest *GroupPolicyBindingRequest
}

func (r IamV1GroupsApiAPIAddGroupPolicyBindingRequest) GroupPolicyBindingRequest(groupPolicyBindingRequest GroupPolicyBindingRequest) IamV1GroupsApiAPIAddGroupPolicyBindingRequest {
	r.groupPolicyBindingRequest = &groupPolicyBindingRequest
	return r
}

func (r IamV1GroupsApiAPIAddGroupPolicyBindingRequest) Execute() (*GroupPolicyResponse, *http.Response, error) {
	return r.ApiService.AddGroupPolicyBindingExecute(r)
}

/*
AddGroupPolicyBinding Assign policies to the group

Assign policies to the group

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Group ID
	@return IamV1GroupsApiAPIAddGroupPolicyBindingRequest
*/
func (a *IamV1GroupsApiAPIService) AddGroupPolicyBinding(ctx context.Context, groupId string) IamV1GroupsApiAPIAddGroupPolicyBindingRequest {
	return IamV1GroupsApiAPIAddGroupPolicyBindingRequest{
		ApiService: a,
		ctx:        ctx,
		groupId:    groupId,
	}
}

// Execute executes the request
//
//	@return GroupPolicyResponse
func (a *IamV1GroupsApiAPIService) AddGroupPolicyBindingExecute(r IamV1GroupsApiAPIAddGroupPolicyBindingRequest) (*GroupPolicyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GroupPolicyResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/groups/{group_id}/policy-bindings"
	localVarPath = strings.Replace(localVarPath, "{"+"group_id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupPolicyBindingRequest == nil {
		return localVarReturnValue, nil, reportError("groupPolicyBindingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupPolicyBindingRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type IamV1GroupsApiAPICreateGroupRequest struct {
	ctx                context.Context
	ApiService         *IamV1GroupsApiAPIService
	groupCreateRequest *GroupCreateRequest
}

func (r IamV1GroupsApiAPICreateGroupRequest) GroupCreateRequest(groupCreateRequest GroupCreateRequest) IamV1GroupsApiAPICreateGroupRequest {
	r.groupCreateRequest = &groupCreateRequest
	return r
}

func (r IamV1GroupsApiAPICreateGroupRequest) Execute() (*GroupShowResponse, *http.Response, error) {
	return r.ApiService.CreateGroupExecute(r)
}

/*
CreateGroup Create a group

Create a group

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return IamV1GroupsApiAPICreateGroupRequest
*/
func (a *IamV1GroupsApiAPIService) CreateGroup(ctx context.Context) IamV1GroupsApiAPICreateGroupRequest {
	return IamV1GroupsApiAPICreateGroupRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GroupShowResponse
func (a *IamV1GroupsApiAPIService) CreateGroupExecute(r IamV1GroupsApiAPICreateGroupRequest) (*GroupShowResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GroupShowResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupCreateRequest == nil {
		return localVarReturnValue, nil, reportError("groupCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupCreateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type IamV1GroupsApiAPIDeleteGroupRequest struct {
	ctx        context.Context
	ApiService *IamV1GroupsApiAPIService
	groupId    string
}

func (r IamV1GroupsApiAPIDeleteGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteGroupExecute(r)
}

/*
DeleteGroup Remove the Group

Remove the Group

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Group ID
	@return IamV1GroupsApiAPIDeleteGroupRequest
*/
func (a *IamV1GroupsApiAPIService) DeleteGroup(ctx context.Context, groupId string) IamV1GroupsApiAPIDeleteGroupRequest {
	return IamV1GroupsApiAPIDeleteGroupRequest{
		ApiService: a,
		ctx:        ctx,
		groupId:    groupId,
	}
}

// Execute executes the request
func (a *IamV1GroupsApiAPIService) DeleteGroupExecute(r IamV1GroupsApiAPIDeleteGroupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return nil, err
		}
	}

	localVarPath := basePath + "/v1/groups/{group_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group_id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type IamV1GroupsApiAPIListGroupRequest struct {
	ctx             context.Context
	ApiService      *IamV1GroupsApiAPIService
	size            *int32
	page            *int32
	sort            *string
	name            *string
	types           *string
	ids             *string
	hasMember       *string
	hasRole         *string
	isCompleted     *string
	creatorName     *string
	creatorEmail    *string
	modifierName    *string
	modifierEmail   *string
	excludeUserId   *string
	excludePolicyId *string
}

// size
func (r IamV1GroupsApiAPIListGroupRequest) Size(size int32) IamV1GroupsApiAPIListGroupRequest {
	r.size = &size
	return r
}

// page
func (r IamV1GroupsApiAPIListGroupRequest) Page(page int32) IamV1GroupsApiAPIListGroupRequest {
	r.page = &page
	return r
}

// sort
func (r IamV1GroupsApiAPIListGroupRequest) Sort(sort string) IamV1GroupsApiAPIListGroupRequest {
	r.sort = &sort
	return r
}

// Group 이름
func (r IamV1GroupsApiAPIListGroupRequest) Name(name string) IamV1GroupsApiAPIListGroupRequest {
	r.name = &name
	return r
}

// Group Types
func (r IamV1GroupsApiAPIListGroupRequest) Types(types string) IamV1GroupsApiAPIListGroupRequest {
	r.types = &types
	return r
}

// Group IDs
func (r IamV1GroupsApiAPIListGroupRequest) Ids(ids string) IamV1GroupsApiAPIListGroupRequest {
	r.ids = &ids
	return r
}

// Group Member 존재 여부
func (r IamV1GroupsApiAPIListGroupRequest) HasMember(hasMember string) IamV1GroupsApiAPIListGroupRequest {
	r.hasMember = &hasMember
	return r
}

// Group Role 존재 여부
func (r IamV1GroupsApiAPIListGroupRequest) HasRole(hasRole string) IamV1GroupsApiAPIListGroupRequest {
	r.hasRole = &hasRole
	return r
}

// Group 완결 여부
func (r IamV1GroupsApiAPIListGroupRequest) IsCompleted(isCompleted string) IamV1GroupsApiAPIListGroupRequest {
	r.isCompleted = &isCompleted
	return r
}

// Group 생성자 성, 이름
func (r IamV1GroupsApiAPIListGroupRequest) CreatorName(creatorName string) IamV1GroupsApiAPIListGroupRequest {
	r.creatorName = &creatorName
	return r
}

// Group 생성자 Email
func (r IamV1GroupsApiAPIListGroupRequest) CreatorEmail(creatorEmail string) IamV1GroupsApiAPIListGroupRequest {
	r.creatorEmail = &creatorEmail
	return r
}

// Group 수정자 성, 이름
func (r IamV1GroupsApiAPIListGroupRequest) ModifierName(modifierName string) IamV1GroupsApiAPIListGroupRequest {
	r.modifierName = &modifierName
	return r
}

// Group 수정자 Email
func (r IamV1GroupsApiAPIListGroupRequest) ModifierEmail(modifierEmail string) IamV1GroupsApiAPIListGroupRequest {
	r.modifierEmail = &modifierEmail
	return r
}

// 제외할 사용자 ID
func (r IamV1GroupsApiAPIListGroupRequest) ExcludeUserId(excludeUserId string) IamV1GroupsApiAPIListGroupRequest {
	r.excludeUserId = &excludeUserId
	return r
}

// 제외할 정책 ID
func (r IamV1GroupsApiAPIListGroupRequest) ExcludePolicyId(excludePolicyId string) IamV1GroupsApiAPIListGroupRequest {
	r.excludePolicyId = &excludePolicyId
	return r
}

func (r IamV1GroupsApiAPIListGroupRequest) Execute() (*GroupPageResponse, *http.Response, error) {
	return r.ApiService.ListGroupExecute(r)
}

/*
ListGroup List Groups

List Groups

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return IamV1GroupsApiAPIListGroupRequest
*/
func (a *IamV1GroupsApiAPIService) ListGroup(ctx context.Context) IamV1GroupsApiAPIListGroupRequest {
	return IamV1GroupsApiAPIListGroupRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GroupPageResponse
func (a *IamV1GroupsApiAPIService) ListGroupExecute(r IamV1GroupsApiAPIListGroupRequest) (*GroupPageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GroupPageResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.types != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "types", r.types, "form", "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ids", r.ids, "form", "")
	}
	if r.hasMember != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_member", r.hasMember, "form", "")
	}
	if r.hasRole != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_role", r.hasRole, "form", "")
	}
	if r.isCompleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_completed", r.isCompleted, "form", "")
	}
	if r.creatorName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creator_name", r.creatorName, "form", "")
	}
	if r.creatorEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creator_email", r.creatorEmail, "form", "")
	}
	if r.modifierName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modifier_name", r.modifierName, "form", "")
	}
	if r.modifierEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modifier_email", r.modifierEmail, "form", "")
	}
	if r.excludeUserId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_user_id", r.excludeUserId, "form", "")
	}
	if r.excludePolicyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_policy_id", r.excludePolicyId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type IamV1GroupsApiAPIListGroupMemberRequest struct {
	ctx          context.Context
	ApiService   *IamV1GroupsApiAPIService
	groupId      string
	size         *int32
	page         *int32
	sort         *string
	userName     *string
	userEmail    *string
	creatorName  *string
	creatorEmail *string
}

// size
func (r IamV1GroupsApiAPIListGroupMemberRequest) Size(size int32) IamV1GroupsApiAPIListGroupMemberRequest {
	r.size = &size
	return r
}

// page
func (r IamV1GroupsApiAPIListGroupMemberRequest) Page(page int32) IamV1GroupsApiAPIListGroupMemberRequest {
	r.page = &page
	return r
}

// sort
func (r IamV1GroupsApiAPIListGroupMemberRequest) Sort(sort string) IamV1GroupsApiAPIListGroupMemberRequest {
	r.sort = &sort
	return r
}

// Group Member 성, 이름
func (r IamV1GroupsApiAPIListGroupMemberRequest) UserName(userName string) IamV1GroupsApiAPIListGroupMemberRequest {
	r.userName = &userName
	return r
}

// Group Member Email
func (r IamV1GroupsApiAPIListGroupMemberRequest) UserEmail(userEmail string) IamV1GroupsApiAPIListGroupMemberRequest {
	r.userEmail = &userEmail
	return r
}

// Group Member 생성자 성, 이름
func (r IamV1GroupsApiAPIListGroupMemberRequest) CreatorName(creatorName string) IamV1GroupsApiAPIListGroupMemberRequest {
	r.creatorName = &creatorName
	return r
}

// Group Member 생성자 Email
func (r IamV1GroupsApiAPIListGroupMemberRequest) CreatorEmail(creatorEmail string) IamV1GroupsApiAPIListGroupMemberRequest {
	r.creatorEmail = &creatorEmail
	return r
}

func (r IamV1GroupsApiAPIListGroupMemberRequest) Execute() (*GroupMemberPageResponse, *http.Response, error) {
	return r.ApiService.ListGroupMemberExecute(r)
}

/*
ListGroupMember Group Member list

Group Member list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Group ID
	@return IamV1GroupsApiAPIListGroupMemberRequest
*/
func (a *IamV1GroupsApiAPIService) ListGroupMember(ctx context.Context, groupId string) IamV1GroupsApiAPIListGroupMemberRequest {
	return IamV1GroupsApiAPIListGroupMemberRequest{
		ApiService: a,
		ctx:        ctx,
		groupId:    groupId,
	}
}

// Execute executes the request
//
//	@return GroupMemberPageResponse
func (a *IamV1GroupsApiAPIService) ListGroupMemberExecute(r IamV1GroupsApiAPIListGroupMemberRequest) (*GroupMemberPageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GroupMemberPageResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/groups/{group_id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"group_id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.userName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_name", r.userName, "form", "")
	}
	if r.userEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_email", r.userEmail, "form", "")
	}
	if r.creatorName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creator_name", r.creatorName, "form", "")
	}
	if r.creatorEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creator_email", r.creatorEmail, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type IamV1GroupsApiAPIListGroupPolicyBindingRequest struct {
	ctx        context.Context
	ApiService *IamV1GroupsApiAPIService
	groupId    string
	size       *int32
	page       *int32
	sort       *string
	policyId   *string
	policyName *string
	policyType *PolicyType
}

// size
func (r IamV1GroupsApiAPIListGroupPolicyBindingRequest) Size(size int32) IamV1GroupsApiAPIListGroupPolicyBindingRequest {
	r.size = &size
	return r
}

// page
func (r IamV1GroupsApiAPIListGroupPolicyBindingRequest) Page(page int32) IamV1GroupsApiAPIListGroupPolicyBindingRequest {
	r.page = &page
	return r
}

// sort
func (r IamV1GroupsApiAPIListGroupPolicyBindingRequest) Sort(sort string) IamV1GroupsApiAPIListGroupPolicyBindingRequest {
	r.sort = &sort
	return r
}

// Policy Id
func (r IamV1GroupsApiAPIListGroupPolicyBindingRequest) PolicyId(policyId string) IamV1GroupsApiAPIListGroupPolicyBindingRequest {
	r.policyId = &policyId
	return r
}

// Policy Name
func (r IamV1GroupsApiAPIListGroupPolicyBindingRequest) PolicyName(policyName string) IamV1GroupsApiAPIListGroupPolicyBindingRequest {
	r.policyName = &policyName
	return r
}

// Policy Type List
func (r IamV1GroupsApiAPIListGroupPolicyBindingRequest) PolicyType(policyType PolicyType) IamV1GroupsApiAPIListGroupPolicyBindingRequest {
	r.policyType = &policyType
	return r
}

func (r IamV1GroupsApiAPIListGroupPolicyBindingRequest) Execute() (*GroupPolicyPageResponse, *http.Response, error) {
	return r.ApiService.ListGroupPolicyBindingExecute(r)
}

/*
ListGroupPolicyBinding Show group policy

Show group policy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Group ID
	@return IamV1GroupsApiAPIListGroupPolicyBindingRequest
*/
func (a *IamV1GroupsApiAPIService) ListGroupPolicyBinding(ctx context.Context, groupId string) IamV1GroupsApiAPIListGroupPolicyBindingRequest {
	return IamV1GroupsApiAPIListGroupPolicyBindingRequest{
		ApiService: a,
		ctx:        ctx,
		groupId:    groupId,
	}
}

// Execute executes the request
//
//	@return GroupPolicyPageResponse
func (a *IamV1GroupsApiAPIService) ListGroupPolicyBindingExecute(r IamV1GroupsApiAPIListGroupPolicyBindingRequest) (*GroupPolicyPageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GroupPolicyPageResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/groups/{group_id}/policy-bindings"
	localVarPath = strings.Replace(localVarPath, "{"+"group_id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.policyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "policy_id", r.policyId, "form", "")
	}
	if r.policyName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "policy_name", r.policyName, "form", "")
	}
	if r.policyType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "policy_type", r.policyType, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type IamV1GroupsApiAPIRemoveGroupMemberRequest struct {
	ctx                      context.Context
	ApiService               *IamV1GroupsApiAPIService
	groupId                  string
	userId                   string
	groupMemberDeleteRequest *GroupMemberDeleteRequest
}

func (r IamV1GroupsApiAPIRemoveGroupMemberRequest) GroupMemberDeleteRequest(groupMemberDeleteRequest GroupMemberDeleteRequest) IamV1GroupsApiAPIRemoveGroupMemberRequest {
	r.groupMemberDeleteRequest = &groupMemberDeleteRequest
	return r
}

func (r IamV1GroupsApiAPIRemoveGroupMemberRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveGroupMemberExecute(r)
}

/*
RemoveGroupMember Remove a User from a Group

Remove a User from a Group

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Group ID
	@param userId User ID
	@return IamV1GroupsApiAPIRemoveGroupMemberRequest
*/
func (a *IamV1GroupsApiAPIService) RemoveGroupMember(ctx context.Context, groupId string, userId string) IamV1GroupsApiAPIRemoveGroupMemberRequest {
	return IamV1GroupsApiAPIRemoveGroupMemberRequest{
		ApiService: a,
		ctx:        ctx,
		groupId:    groupId,
		userId:     userId,
	}
}

// Execute executes the request
func (a *IamV1GroupsApiAPIService) RemoveGroupMemberExecute(r IamV1GroupsApiAPIRemoveGroupMemberRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return nil, err
		}
	}

	localVarPath := basePath + "/v1/groups/{group_id}/members/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group_id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupMemberDeleteRequest == nil {
		return nil, reportError("groupMemberDeleteRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupMemberDeleteRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type IamV1GroupsApiAPIRemoveGroupPolicyBindingRequest struct {
	ctx        context.Context
	ApiService *IamV1GroupsApiAPIService
	groupId    string
	policyId   string
}

func (r IamV1GroupsApiAPIRemoveGroupPolicyBindingRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveGroupPolicyBindingExecute(r)
}

/*
RemoveGroupPolicyBinding Remove policy assignment from group

Remove policy assignment from group

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Group ID
	@param policyId Policy ID
	@return IamV1GroupsApiAPIRemoveGroupPolicyBindingRequest
*/
func (a *IamV1GroupsApiAPIService) RemoveGroupPolicyBinding(ctx context.Context, groupId string, policyId string) IamV1GroupsApiAPIRemoveGroupPolicyBindingRequest {
	return IamV1GroupsApiAPIRemoveGroupPolicyBindingRequest{
		ApiService: a,
		ctx:        ctx,
		groupId:    groupId,
		policyId:   policyId,
	}
}

// Execute executes the request
func (a *IamV1GroupsApiAPIService) RemoveGroupPolicyBindingExecute(r IamV1GroupsApiAPIRemoveGroupPolicyBindingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return nil, err
		}
	}

	localVarPath := basePath + "/v1/groups/{group_id}/policy-bindings/{policy_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group_id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policy_id"+"}", url.PathEscape(parameterValueToString(r.policyId, "policyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type IamV1GroupsApiAPISetGroupRequest struct {
	ctx             context.Context
	ApiService      *IamV1GroupsApiAPIService
	groupId         string
	groupSetRequest *GroupSetRequest
}

func (r IamV1GroupsApiAPISetGroupRequest) GroupSetRequest(groupSetRequest GroupSetRequest) IamV1GroupsApiAPISetGroupRequest {
	r.groupSetRequest = &groupSetRequest
	return r
}

func (r IamV1GroupsApiAPISetGroupRequest) Execute() (*GroupShowResponse, *http.Response, error) {
	return r.ApiService.SetGroupExecute(r)
}

/*
SetGroup Modify a Group

Modify a Group

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Group ID
	@return IamV1GroupsApiAPISetGroupRequest
*/
func (a *IamV1GroupsApiAPIService) SetGroup(ctx context.Context, groupId string) IamV1GroupsApiAPISetGroupRequest {
	return IamV1GroupsApiAPISetGroupRequest{
		ApiService: a,
		ctx:        ctx,
		groupId:    groupId,
	}
}

// Execute executes the request
//
//	@return GroupShowResponse
func (a *IamV1GroupsApiAPIService) SetGroupExecute(r IamV1GroupsApiAPISetGroupRequest) (*GroupShowResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GroupShowResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/groups/{group_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group_id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupSetRequest == nil {
		return localVarReturnValue, nil, reportError("groupSetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupSetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type IamV1GroupsApiAPIShowGroupRequest struct {
	ctx        context.Context
	ApiService *IamV1GroupsApiAPIService
	groupId    string
}

func (r IamV1GroupsApiAPIShowGroupRequest) Execute() (*GroupShowResponse, *http.Response, error) {
	return r.ApiService.ShowGroupExecute(r)
}

/*
ShowGroup Get a Group

Get a Group

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Group ID
	@return IamV1GroupsApiAPIShowGroupRequest
*/
func (a *IamV1GroupsApiAPIService) ShowGroup(ctx context.Context, groupId string) IamV1GroupsApiAPIShowGroupRequest {
	return IamV1GroupsApiAPIShowGroupRequest{
		ApiService: a,
		ctx:        ctx,
		groupId:    groupId,
	}
}

// Execute executes the request
//
//	@return GroupShowResponse
func (a *IamV1GroupsApiAPIService) ShowGroupExecute(r IamV1GroupsApiAPIShowGroupRequest) (*GroupShowResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GroupShowResponse
	)

	var basePath string

	if a.client.cfg.Endpoint != "" {
		basePath = a.client.cfg.Endpoint
	} else {
		var err error
		catalog := scpsdk.NewCatalog(
			a.client.cfg.AuthUrl,
			a.client.cfg.Credentials.AccessKey,
			a.client.cfg.Credentials.SecretKey,
			a.client.cfg.DefaultRegion,
		)
		basePath, err = catalog.GetEndpoint(
			a.client.cfg.ServiceType, a.client.cfg.Region, a.client.cfg.AccountId,
		)
		if err != nil {
			return localVarReturnValue, nil, err
		}
	}

	localVarPath := basePath + "/v1/groups/{group_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group_id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Auth-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &scpsdk.GenericOpenAPIError{
			ResponseBody: localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
